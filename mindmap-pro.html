<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow Pro - 스마트 마인드맵</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
        }
        
        /* Glassmorphism Effects */
        .glass {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        .glass-dark {
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        /* Canvas */
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
        }
        
        #mindmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
            transition: none;
            will-change: transform;
        }
        
        #mindmap-canvas.panning {
            cursor: grabbing;
        }
        
        /* Nodes */
        .node {
            position: absolute;
            padding: 14px 24px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            cursor: move;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            user-select: none;
            min-width: 140px;
            text-align: center;
            border: 3px solid transparent;
            transform-origin: center;
            will-change: transform;
        }
        
        .node:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.15);
        }
        
        .node.selected {
            border-color: #fff;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3), 0 15px 50px rgba(0, 0, 0, 0.2);
            transform: scale(1.05);
        }
        
        .node.dragging {
            opacity: 0.8;
            transform: scale(1.1) rotate(2deg);
            cursor: grabbing;
        }
        
        /* Node Levels with Beautiful Gradients */
        .node.root {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 700;
            font-size: 20px;
            padding: 18px 32px;
            box-shadow: 0 15px 50px rgba(102, 126, 234, 0.4);
        }
        
        .node.level-1 {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            font-weight: 600;
            box-shadow: 0 12px 40px rgba(240, 147, 251, 0.3);
        }
        
        .node.level-2 {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            font-weight: 500;
            box-shadow: 0 12px 40px rgba(79, 172, 254, 0.3);
        }
        
        .node.level-3 {
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            color: white;
            box-shadow: 0 12px 40px rgba(67, 233, 123, 0.3);
        }
        
        .node.level-4 {
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            color: #333;
            box-shadow: 0 12px 40px rgba(252, 182, 159, 0.3);
        }
        
        /* Node Text Input */
        .node-text {
            outline: none;
            background: transparent;
            border: none;
            width: 100%;
            text-align: center;
            font-size: 15px;
            font-weight: 500;
            color: inherit;
            pointer-events: all;
        }
        
        .node.root .node-text {
            font-size: 20px;
            font-weight: 700;
        }
        
        /* Connection Points */
        .connection-point {
            position: absolute;
            width: 14px;
            height: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 50%;
            cursor: crosshair;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 15;
        }
        
        .node:hover .connection-point {
            opacity: 1;
            transform: scale(1);
        }
        
        .connection-point:hover {
            transform: scale(1.3);
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .connection-point.active {
            opacity: 1;
            transform: scale(1.5);
            background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1.5); }
            50% { transform: scale(1.8); }
        }
        
        .connection-point.right { right: -7px; top: 50%; transform: translateY(-50%); }
        .connection-point.left { left: -7px; top: 50%; transform: translateY(-50%); }
        .connection-point.top { top: -7px; left: 50%; transform: translateX(-50%); }
        .connection-point.bottom { bottom: -7px; left: 50%; transform: translateX(-50%); }
        
        /* Delete Button */
        .delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            z-index: 20;
            border: 3px solid white;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(238, 90, 36, 0.3);
        }
        
        .node:hover .delete-btn {
            display: flex;
        }
        
        .delete-btn:hover {
            transform: scale(1.1) rotate(90deg);
        }
        
        /* Color Palette */
        .color-palette {
            position: absolute;
            bottom: -55px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 16px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            display: none;
            flex-direction: row;
            gap: 8px;
            z-index: 30;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .node.selected .color-palette {
            display: flex;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .color-option {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .color-option::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .color-option:hover {
            transform: translateY(-4px) scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
        }
        
        .color-option:hover::after {
            transform: translate(-50%, -50%) scale(2);
        }
        
        /* Toolbar */
        .toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 20px;
            padding: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 8px;
            z-index: 100;
            backdrop-filter: blur(20px);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .toolbar-btn {
            padding: 10px 18px;
            border-radius: 12px;
            background: white;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #4a5568;
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.3);
        }
        
        /* Sidebar Navigation */
        .sidebar-nav {
            position: fixed;
            left: 20px;
            top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
        }
        
        .nav-btn {
            padding: 12px 24px;
            border-radius: 14px;
            background: white;
            color: #4a5568;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: all 0.2s;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }
        
        .nav-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            transform: translateX(5px);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.3);
        }
        
        /* Outline View */
        .outline-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: white;
            box-shadow: -10px 0 40px rgba(0, 0, 0, 0.1);
            transition: right 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 90;
            overflow-y: auto;
            padding: 30px;
        }
        
        .outline-panel.open {
            right: 0;
        }
        
        .outline-item {
            padding: 12px 16px;
            margin: 4px 0;
            background: #f7fafc;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid transparent;
        }
        
        .outline-item:hover {
            background: #edf2f7;
            transform: translateX(5px);
            border-left-color: #667eea;
        }
        
        .outline-item.level-0 { margin-left: 0; font-weight: 700; }
        .outline-item.level-1 { margin-left: 20px; font-weight: 600; }
        .outline-item.level-2 { margin-left: 40px; font-weight: 500; }
        .outline-item.level-3 { margin-left: 60px; }
        .outline-item.level-4 { margin-left: 80px; }
        
        /* Zoom Controls */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 16px;
            padding: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }
        
        .zoom-btn {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            background: white;
            border: 2px solid #e2e8f0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 18px;
            color: #4a5568;
        }
        
        .zoom-btn:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
            transform: scale(1.1);
        }
        
        /* Shortcuts Modal */
        .shortcuts-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s;
            max-width: 500px;
            width: 90%;
        }
        
        .shortcuts-modal.open {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }
        
        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e2e8f0;
        }
        
        .shortcut-key {
            background: #f7fafc;
            padding: 4px 8px;
            border-radius: 6px;
            font-family: monospace;
            font-weight: 600;
        }
        
        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 30px;
            left: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
            transition: all 0.3s;
            font-size: 24px;
            z-index: 100;
        }
        
        .fab:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.5);
        }
        
        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: all 0.3s;
            z-index: 1000;
        }
        
        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        
        /* Performance Optimizations */
        .hardware-accelerated {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* Loading Spinner */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            z-index: 1000;
            display: none;
        }
        
        @keyframes spin {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading Spinner -->
    <div class="loading" id="loading"></div>
    
    <!-- Navigation -->
    <div class="sidebar-nav">
        <a href="todomaster_complete.html" class="nav-btn">
            <span>📋</span>
            <span>Todo List</span>
        </a>
        <button class="nav-btn" onclick="mindMap.toggleOutline()">
            <span>📝</span>
            <span>아웃라인</span>
        </button>
        <button class="nav-btn" onclick="mindMap.toggleShortcuts()">
            <span>⌨️</span>
            <span>단축키</span>
        </button>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <button class="toolbar-btn" onclick="mindMap.addNode()">
            <span>➕</span>
            <span>노드</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.undo()">
            <span>↶</span>
            <span>실행취소</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.redo()">
            <span>↷</span>
            <span>다시실행</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.centerView()">
            <span>🎯</span>
            <span>중앙</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.saveToLocal()">
            <span>💾</span>
            <span>저장</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.exportData()">
            <span>📤</span>
            <span>내보내기</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.clearAll()">
            <span>🗑️</span>
            <span>초기화</span>
        </button>
    </div>
    
    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="mindMap.zoomIn()">➕</button>
        <button class="zoom-btn" onclick="mindMap.resetZoom()">⟲</button>
        <button class="zoom-btn" onclick="mindMap.zoomOut()">➖</button>
    </div>
    
    <!-- Floating Action Button -->
    <div class="fab" onclick="mindMap.quickAdd()">✨</div>
    
    <!-- Main Canvas -->
    <div id="canvas-container">
        <svg id="mindmap-canvas" width="10000" height="10000" class="hardware-accelerated">
            <defs>
                <linearGradient id="gradient-default" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#667eea;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#764ba2;stop-opacity:1" />
                </linearGradient>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
            </defs>
            <g id="connections"></g>
        </svg>
        <div id="nodes-container" class="hardware-accelerated"></div>
    </div>
    
    <!-- Outline Panel -->
    <div class="outline-panel" id="outline-panel">
        <h2 style="font-size: 24px; font-weight: 700; margin-bottom: 20px; color: #2d3748;">
            📝 아웃라인 뷰
        </h2>
        <div id="outline-content"></div>
        <div style="margin-top: 30px;">
            <input type="text" id="outline-input" placeholder="텍스트로 노드 추가 (Enter)..." 
                   style="width: 100%; padding: 12px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 14px;">
        </div>
    </div>
    
    <!-- Shortcuts Modal -->
    <div class="shortcuts-modal" id="shortcuts-modal">
        <h2 style="font-size: 24px; font-weight: 700; margin-bottom: 20px;">⌨️ 키보드 단축키</h2>
        <div class="shortcut-item">
            <span>자식 노드 추가</span>
            <span class="shortcut-key">Enter</span>
        </div>
        <div class="shortcut-item">
            <span>형제 노드 추가</span>
            <span class="shortcut-key">Tab</span>
        </div>
        <div class="shortcut-item">
            <span>노드 삭제</span>
            <span class="shortcut-key">Delete</span>
        </div>
        <div class="shortcut-item">
            <span>실행 취소</span>
            <span class="shortcut-key">Ctrl+Z</span>
        </div>
        <div class="shortcut-item">
            <span>다시 실행</span>
            <span class="shortcut-key">Ctrl+Y</span>
        </div>
        <div class="shortcut-item">
            <span>복사</span>
            <span class="shortcut-key">Ctrl+C</span>
        </div>
        <div class="shortcut-item">
            <span>붙여넣기</span>
            <span class="shortcut-key">Ctrl+V</span>
        </div>
        <div class="shortcut-item">
            <span>전체 선택</span>
            <span class="shortcut-key">Ctrl+A</span>
        </div>
        <div class="shortcut-item">
            <span>검색</span>
            <span class="shortcut-key">Ctrl+F</span>
        </div>
        <button onclick="mindMap.toggleShortcuts()" 
                style="margin-top: 20px; padding: 12px 24px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                       color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; width: 100%;">
            닫기
        </button>
    </div>
    
    <!-- Toast Notification -->
    <div class="toast" id="toast">
        <span id="toast-icon">✅</span>
        <span id="toast-message">저장되었습니다</span>
    </div>
    
    <!-- Hidden File Input -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <script>
        class MindMapPro {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.selectedNode = null;
                this.copiedNode = null;
                this.draggedNode = null;
                this.connectionDrag = null;
                this.panStart = null;
                this.viewOffset = { x: 0, y: 0 };
                this.zoom = 1;
                this.nodeIdCounter = 0;
                this.resizingNode = null;
                this.resizeStart = null;
                
                // Undo/Redo History
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 50;
                
                // DOM Elements
                this.canvas = document.getElementById('mindmap-canvas');
                this.container = document.getElementById('canvas-container');
                this.nodesContainer = document.getElementById('nodes-container');
                this.connectionsGroup = document.getElementById('connections');
                this.outlinePanel = document.getElementById('outline-panel');
                this.shortcutsModal = document.getElementById('shortcuts-modal');
                
                // Performance optimizations
                this.isDragging = false;
                
                this.init();
            }
            
            init() {
                this.loadFromLocal();
                
                if (this.nodes.size === 0) {
                    this.createRootNode();
                }
                
                this.setupEventListeners();
                this.updateOutline();
                
                setTimeout(() => {
                    this.centerView();
                    document.getElementById('loading').style.display = 'none';
                }, 100);
            }
            
            createRootNode() {
                const rootNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: '중심 아이디어',
                    x: 5000,
                    y: 5000,
                    level: 0,
                    customColor: null,
                    collapsed: false
                };
                this.nodes.set(rootNode.id, rootNode);
                this.renderNode(rootNode);
                this.saveState();
            }
            
            setupEventListeners() {
                // Canvas panning with improved performance
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.target === this.canvas) {
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.canvas.classList.add('panning');
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.panStart) {
                        const dx = e.clientX - this.panStart.x;
                        const dy = e.clientY - this.panStart.y;
                        this.viewOffset.x += dx;
                        this.viewOffset.y += dy;
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.updateView();
                    }
                    
                    if (this.connectionDrag) {
                        this.updateTempConnection(e);
                    }
                    
                    if (this.resizingNode) {
                        const nodeEl = document.getElementById(this.resizingNode.id);
                        if (nodeEl) {
                            const dx = e.clientX - this.resizeStart.x;
                            const dy = e.clientY - this.resizeStart.y;
                            const newWidth = Math.max(100, this.resizeStart.width + dx);
                            const newHeight = Math.max(40, this.resizeStart.height + dy);
                            
                            nodeEl.style.width = newWidth + 'px';
                            nodeEl.style.height = newHeight + 'px';
                            
                            // Save dimensions
                            this.resizingNode.width = newWidth;
                            this.resizingNode.height = newHeight;
                            
                            this.updateConnections();
                        }
                    }
                    
                    if (this.draggedNode) {
                        if (!this.isDragging) {
                            this.isDragging = true;
                            document.getElementById(this.draggedNode.id).classList.add('dragging');
                        }
                        
                        this.draggedNode.x = e.clientX - this.dragOffset.x - this.viewOffset.x;
                        this.draggedNode.y = e.clientY - this.dragOffset.y - this.viewOffset.y;
                        const nodeEl = document.getElementById(this.draggedNode.id);
                        if (nodeEl) {
                            nodeEl.style.left = this.draggedNode.x + 'px';
                            nodeEl.style.top = this.draggedNode.y + 'px';
                            this.updateConnections();
                        }
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.panStart = null;
                    this.canvas.classList.remove('panning');
                    
                    if (this.connectionDrag) {
                        this.endConnectionDrag();
                    }
                    
                    if (this.resizingNode) {
                        this.resizingNode = null;
                        this.resizeStart = null;
                        this.saveState();
                        this.saveToLocal();
                    }
                    
                    if (this.draggedNode) {
                        document.getElementById(this.draggedNode.id).classList.remove('dragging');
                        this.isDragging = false;
                        this.draggedNode = null;
                        this.saveState();
                        this.saveToLocal();
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Prevent default for our shortcuts
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                            case 'z':
                                e.preventDefault();
                                this.undo();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.redo();
                                break;
                            case 'c':
                                e.preventDefault();
                                this.copy();
                                break;
                            case 'v':
                                e.preventDefault();
                                this.paste();
                                break;
                            case 'a':
                                e.preventDefault();
                                this.selectAll();
                                break;
                            case 'f':
                                e.preventDefault();
                                this.search();
                                break;
                            case 's':
                                e.preventDefault();
                                this.saveToLocal();
                                this.showToast('💾', '저장되었습니다');
                                break;
                        }
                    } else {
                        switch(e.key) {
                            case 'Delete':
                                if (this.selectedNode) {
                                    this.deleteNode(this.selectedNode);
                                }
                                break;
                            case 'Tab':
                                e.preventDefault();
                                if (this.selectedNode) {
                                    this.addSiblingNode(this.selectedNode);
                                }
                                break;
                            case 'Enter':
                                if (e.target.id === 'outline-input') {
                                    this.addNodeFromOutline();
                                } else if (this.selectedNode) {
                                    e.preventDefault();
                                    this.addChildNode(this.selectedNode);
                                }
                                break;
                            case 'Escape':
                                this.deselectAll();
                                break;
                        }
                    }
                });
                
                // Outline input
                document.getElementById('outline-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.addNodeFromOutline();
                    }
                });
                
                // Click outside to close modals
                document.addEventListener('click', (e) => {
                    if (e.target === this.shortcutsModal) {
                        this.toggleShortcuts();
                    }
                });
            }
            
            renderNode(nodeData) {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                nodeEl.id = nodeData.id;
                nodeEl.style.left = nodeData.x + 'px';
                nodeEl.style.top = nodeData.y + 'px';
                
                // Apply saved dimensions if exist
                if (nodeData.width) {
                    nodeEl.style.width = nodeData.width + 'px';
                }
                if (nodeData.height) {
                    nodeEl.style.height = nodeData.height + 'px';
                }
                
                // Apply custom color or level-based color
                if (nodeData.customColor) {
                    nodeEl.style.background = nodeData.customColor;
                    nodeEl.style.color = 'white';
                } else {
                    const levelClass = `level-${Math.min(nodeData.level, 4)}`;
                    if (nodeData.level === 0) {
                        nodeEl.classList.add('root');
                    } else {
                        nodeEl.classList.add(levelClass);
                    }
                }
                
                // Node text
                const textEl = document.createElement('input');
                textEl.className = 'node-text';
                textEl.value = nodeData.text;
                textEl.addEventListener('input', (e) => {
                    nodeData.text = e.target.value;
                    this.updateOutline();
                    this.saveToLocal();
                });
                textEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectNode(nodeData.id);
                });
                textEl.addEventListener('focus', () => {
                    this.selectNode(nodeData.id);
                });
                nodeEl.appendChild(textEl);
                
                // Color palette
                if (nodeData.level > 0) {
                    const colorPalette = document.createElement('div');
                    colorPalette.className = 'color-palette';
                    
                    const gradients = [
                        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                        'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                        'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                        'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                        'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)',
                        'linear-gradient(135deg, #fccb90 0%, #d57eeb 100%)',
                        'linear-gradient(135deg, #e0c3fc 0%, #8ec5fc 100%)',
                        'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
                    ];
                    
                    gradients.forEach((gradient) => {
                        const colorOption = document.createElement('div');
                        colorOption.className = 'color-option';
                        colorOption.style.background = gradient;
                        colorOption.addEventListener('click', (e) => {
                            e.stopPropagation();
                            nodeData.customColor = gradient;
                            nodeEl.style.background = gradient;
                            nodeEl.style.color = 'white';
                            this.saveState();
                            this.saveToLocal();
                        });
                        colorPalette.appendChild(colorOption);
                    });
                    
                    nodeEl.appendChild(colorPalette);
                }
                
                // Connection points
                ['top', 'right', 'bottom', 'left'].forEach(pos => {
                    const point = document.createElement('div');
                    point.className = `connection-point ${pos} hardware-accelerated`;
                    
                    point.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startConnectionDrag(nodeData.id, pos, e);
                    });
                    
                    nodeEl.appendChild(point);
                });
                
                // Delete button
                if (nodeData.level !== 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '✕';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteNode(nodeData.id);
                    });
                    nodeEl.appendChild(deleteBtn);
                }
                
                // Resize handle (bottom-right corner)
                const resizeHandle = document.createElement('div');
                resizeHandle.style.cssText = `
                    position: absolute;
                    bottom: -5px;
                    right: -5px;
                    width: 15px;
                    height: 15px;
                    background: linear-gradient(135deg, transparent 50%, #667eea 50%);
                    cursor: nwse-resize;
                    opacity: 0;
                    transition: opacity 0.2s;
                    border-radius: 0 0 20px 0;
                `;
                nodeEl.appendChild(resizeHandle);
                
                // Show resize handle on hover
                nodeEl.addEventListener('mouseenter', () => {
                    resizeHandle.style.opacity = '0.5';
                });
                
                nodeEl.addEventListener('mouseleave', () => {
                    if (!this.resizingNode) {
                        resizeHandle.style.opacity = '0';
                    }
                });
                
                // Resize functionality
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.resizingNode = nodeData;
                    this.resizeStart = {
                        x: e.clientX,
                        y: e.clientY,
                        width: nodeEl.offsetWidth,
                        height: nodeEl.offsetHeight
                    };
                });
                
                // Node drag
                nodeEl.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('connection-point') || 
                        e.target.classList.contains('delete-btn') ||
                        e.target.classList.contains('node-text') ||
                        e.target.classList.contains('color-option') ||
                        e.target === resizeHandle) return;
                    
                    this.draggedNode = nodeData;
                    this.dragOffset = {
                        x: e.clientX - nodeData.x - this.viewOffset.x,
                        y: e.clientY - nodeData.y - this.viewOffset.y
                    };
                    this.selectNode(nodeData.id);
                });
                
                this.nodesContainer.appendChild(nodeEl);
            }
            
            // Undo/Redo functionality
            saveState() {
                const state = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter
                };
                
                // Remove any states after current index
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                // Add new state
                this.history.push(JSON.stringify(state));
                
                // Limit history size
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                    this.showToast('↶', '실행 취소');
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                    this.showToast('↷', '다시 실행');
                }
            }
            
            loadState(stateStr) {
                const state = JSON.parse(stateStr);
                
                // Clear current state
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                this.nodes.clear();
                this.connections.clear();
                
                // Load nodes
                state.nodes.forEach(node => {
                    this.nodes.set(node.id, node);
                    this.renderNode(node);
                });
                
                // Load connections
                state.connections.forEach(conn => {
                    this.connections.set(conn.id, {
                        from: conn.from,
                        to: conn.to,
                        fromPos: conn.fromPos || 'right',
                        toPos: conn.toPos || 'left'
                    });
                    this.renderConnection(conn.id);
                });
                
                this.nodeIdCounter = state.nodeIdCounter;
                this.updateOutline();
            }
            
            // Copy/Paste functionality
            copy() {
                if (this.selectedNode) {
                    const node = this.nodes.get(this.selectedNode);
                    if (node) {
                        this.copiedNode = JSON.parse(JSON.stringify(node));
                        this.showToast('📋', '복사됨');
                    }
                }
            }
            
            paste() {
                if (this.copiedNode) {
                    const newNode = {
                        ...this.copiedNode,
                        id: 'node_' + this.nodeIdCounter++,
                        x: this.copiedNode.x + 50,
                        y: this.copiedNode.y + 50
                    };
                    
                    this.nodes.set(newNode.id, newNode);
                    this.renderNode(newNode);
                    this.selectNode(newNode.id);
                    this.saveState();
                    this.saveToLocal();
                    this.showToast('📋', '붙여넣기 완료');
                }
            }
            
            // Select All
            selectAll() {
                // Visual indication only - actual multi-select would be complex
                this.nodes.forEach((node) => {
                    const nodeEl = document.getElementById(node.id);
                    if (nodeEl) {
                        nodeEl.classList.add('selected');
                    }
                });
                this.showToast('✅', '전체 선택');
            }
            
            deselectAll() {
                document.querySelectorAll('.node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                this.selectedNode = null;
            }
            
            // Search functionality
            search() {
                const query = prompt('검색할 텍스트를 입력하세요:');
                if (query) {
                    let found = false;
                    this.nodes.forEach((node) => {
                        if (node.text.toLowerCase().includes(query.toLowerCase())) {
                            this.selectNode(node.id);
                            this.centerOnNode(node.id);
                            found = true;
                            return;
                        }
                    });
                    
                    if (found) {
                        this.showToast('🔍', '찾았습니다');
                    } else {
                        this.showToast('❌', '찾을 수 없습니다');
                    }
                }
            }
            
            centerOnNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (node) {
                    this.viewOffset.x = window.innerWidth / 2 - node.x;
                    this.viewOffset.y = window.innerHeight / 2 - node.y;
                    this.updateView();
                }
            }
            
            // Outline View
            toggleOutline() {
                this.outlinePanel.classList.toggle('open');
                this.updateOutline();
            }
            
            updateOutline() {
                const outlineContent = document.getElementById('outline-content');
                outlineContent.innerHTML = '';
                
                // Build tree structure
                const rootNodes = Array.from(this.nodes.values()).filter(n => n.level === 0);
                
                rootNodes.forEach(root => {
                    this.renderOutlineItem(root, outlineContent);
                });
            }
            
            renderOutlineItem(node, container) {
                const item = document.createElement('div');
                item.className = `outline-item level-${node.level}`;
                item.textContent = node.text;
                item.addEventListener('click', () => {
                    this.selectNode(node.id);
                    this.centerOnNode(node.id);
                });
                
                container.appendChild(item);
                
                // Find children
                const children = this.getNodeChildren(node.id);
                children.forEach(child => {
                    this.renderOutlineItem(child, container);
                });
            }
            
            getNodeChildren(nodeId) {
                const children = [];
                this.connections.forEach((conn) => {
                    if (conn.from === nodeId) {
                        const child = this.nodes.get(conn.to);
                        if (child) children.push(child);
                    }
                });
                return children;
            }
            
            addNodeFromOutline() {
                const input = document.getElementById('outline-input');
                const text = input.value.trim();
                
                if (text) {
                    const parentId = this.selectedNode || Array.from(this.nodes.keys())[0];
                    const parent = this.nodes.get(parentId);
                    
                    if (parent) {
                        const newNode = {
                            id: 'node_' + this.nodeIdCounter++,
                            text: text,
                            x: parent.x + 150 + Math.random() * 100,
                            y: parent.y + Math.random() * 100 - 50,
                            level: parent.level + 1,
                            customColor: null
                        };
                        
                        this.nodes.set(newNode.id, newNode);
                        this.renderNode(newNode);
                        this.createConnection(parentId, newNode.id, 'right', 'left');
                        this.selectNode(newNode.id);
                        this.saveState();
                        this.saveToLocal();
                        this.updateOutline();
                        
                        input.value = '';
                        this.showToast('✅', '노드 추가됨');
                    }
                }
            }
            
            // Shortcuts Modal
            toggleShortcuts() {
                this.shortcutsModal.classList.toggle('open');
            }
            
            // Quick Add with FAB
            quickAdd() {
                if (this.selectedNode) {
                    this.addChildNode(this.selectedNode);
                } else {
                    this.addNode();
                }
                this.showToast('✨', '노드 추가됨');
            }
            
            // Toast notifications
            showToast(icon, message) {
                const toast = document.getElementById('toast');
                const toastIcon = document.getElementById('toast-icon');
                const toastMessage = document.getElementById('toast-message');
                
                toastIcon.textContent = icon;
                toastMessage.textContent = message;
                
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 2000);
            }
            
            // Connection management
            startConnectionDrag(nodeId, position, event) {
                this.connectionDrag = {
                    fromNode: nodeId,
                    fromPos: position,
                    toNode: null,
                    toPos: null
                };
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = 'temp-connection';
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', 'url(#gradient-default)');
                path.setAttribute('stroke-width', '3');
                path.setAttribute('stroke-dasharray', '8,4');
                path.setAttribute('stroke-linecap', 'round');
                path.style.pointerEvents = 'none';
                path.style.opacity = '0.8';
                path.setAttribute('filter', 'url(#glow)');
                this.connectionsGroup.appendChild(path);
                
                document.querySelectorAll('.connection-point').forEach(point => {
                    point.addEventListener('mouseenter', this.handleConnectionPointEnter);
                    point.addEventListener('mouseleave', this.handleConnectionPointLeave);
                    point.addEventListener('mouseup', this.handleConnectionPointUp);
                });
                
                this.updateTempConnection(event);
            }
            
            handleConnectionPointEnter = (e) => {
                if (!this.connectionDrag) return;
                const nodeEl = e.target.closest('.node');
                if (nodeEl && nodeEl.id !== this.connectionDrag.fromNode) {
                    e.target.classList.add('active');
                    this.connectionDrag.toNode = nodeEl.id;
                    this.connectionDrag.toPos = e.target.className.split(' ').find(c => 
                        ['top', 'right', 'bottom', 'left'].includes(c));
                }
            }
            
            handleConnectionPointLeave = (e) => {
                e.target.classList.remove('active');
                if (this.connectionDrag) {
                    this.connectionDrag.toNode = null;
                    this.connectionDrag.toPos = null;
                }
            }
            
            handleConnectionPointUp = (e) => {
                if (!this.connectionDrag) return;
                const nodeEl = e.target.closest('.node');
                if (nodeEl && nodeEl.id !== this.connectionDrag.fromNode) {
                    const toPos = e.target.className.split(' ').find(c => 
                        ['top', 'right', 'bottom', 'left'].includes(c));
                    this.createConnection(
                        this.connectionDrag.fromNode,
                        nodeEl.id,
                        this.connectionDrag.fromPos,
                        toPos
                    );
                }
            }
            
            endConnectionDrag() {
                const tempPath = document.getElementById('temp-connection');
                if (tempPath) tempPath.remove();
                
                document.querySelectorAll('.connection-point').forEach(point => {
                    point.classList.remove('active');
                    point.removeEventListener('mouseenter', this.handleConnectionPointEnter);
                    point.removeEventListener('mouseleave', this.handleConnectionPointLeave);
                    point.removeEventListener('mouseup', this.handleConnectionPointUp);
                });
                
                this.connectionDrag = null;
            }
            
            updateTempConnection(e) {
                const tempPath = document.getElementById('temp-connection');
                if (!tempPath || !this.connectionDrag) return;
                
                const fromNode = this.nodes.get(this.connectionDrag.fromNode);
                if (!fromNode) return;
                
                const fromPoint = this.getConnectionPoint(fromNode, this.connectionDrag.fromPos);
                const toX = e.clientX - this.viewOffset.x;
                const toY = e.clientY - this.viewOffset.y;
                
                const dx = toX - fromPoint.x;
                const dy = toY - fromPoint.y;
                const cx = fromPoint.x + dx * 0.5;
                
                const d = `M ${fromPoint.x} ${fromPoint.y} Q ${cx} ${fromPoint.y}, ${toX} ${toY}`;
                tempPath.setAttribute('d', d);
            }
            
            createConnection(fromNodeId, toNodeId, fromPos, toPos) {
                const connectionId = `${fromNodeId}_${toNodeId}`;
                const reverseConnectionId = `${toNodeId}_${fromNodeId}`;
                
                if (this.connections.has(connectionId) || this.connections.has(reverseConnectionId)) {
                    return;
                }
                
                const connection = {
                    from: fromNodeId,
                    to: toNodeId,
                    fromPos: fromPos,
                    toPos: toPos
                };
                
                this.connections.set(connectionId, connection);
                this.renderConnection(connectionId);
                this.saveState();
                this.saveToLocal();
            }
            
            renderConnection(connectionId) {
                const connection = this.connections.get(connectionId);
                if (!connection) return;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `connection_${connectionId}`;
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', 'url(#gradient-default)');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('stroke-dasharray', '10,5');
                path.setAttribute('stroke-linecap', 'round');
                path.style.cursor = 'pointer';
                path.style.opacity = '0.6';
                path.style.transition = 'all 0.3s';
                
                path.addEventListener('mouseenter', () => {
                    path.setAttribute('stroke-width', '3');
                    path.style.opacity = '1';
                    path.setAttribute('filter', 'url(#glow)');
                });
                
                path.addEventListener('mouseleave', () => {
                    path.setAttribute('stroke-width', '2');
                    path.style.opacity = '0.6';
                    path.removeAttribute('filter');
                });
                
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('이 연결을 삭제하시겠습니까?')) {
                        this.deleteConnection(connectionId);
                    }
                });
                
                this.updateConnectionPath(path, connection);
                this.connectionsGroup.appendChild(path);
            }
            
            updateConnectionPath(path, connection) {
                const fromNode = this.nodes.get(connection.from);
                const toNode = this.nodes.get(connection.to);
                if (!fromNode || !toNode) return;
                
                const fromPoint = this.getConnectionPoint(fromNode, connection.fromPos);
                const toPoint = this.getConnectionPoint(toNode, connection.toPos);
                
                const dx = toPoint.x - fromPoint.x;
                const dy = toPoint.y - fromPoint.y;
                
                let cx1, cy1, cx2, cy2;
                if (Math.abs(dx) > Math.abs(dy)) {
                    cx1 = fromPoint.x + dx * 0.5;
                    cy1 = fromPoint.y;
                    cx2 = fromPoint.x + dx * 0.5;
                    cy2 = toPoint.y;
                } else {
                    cx1 = fromPoint.x;
                    cy1 = fromPoint.y + dy * 0.5;
                    cx2 = toPoint.x;
                    cy2 = fromPoint.y + dy * 0.5;
                }
                
                const d = `M ${fromPoint.x} ${fromPoint.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${toPoint.x} ${toPoint.y}`;
                path.setAttribute('d', d);
            }
            
            updateConnections() {
                this.connections.forEach((connection, id) => {
                    const path = document.getElementById(`connection_${id}`);
                    if (path) {
                        this.updateConnectionPath(path, connection);
                    }
                });
            }
            
            getConnectionPoint(node, position) {
                const nodeEl = document.getElementById(node.id);
                if (!nodeEl) return { x: node.x + 70, y: node.y + 30 };
                
                const rect = nodeEl.getBoundingClientRect();
                const width = rect.width / this.zoom;
                const height = rect.height / this.zoom;
                
                switch(position) {
                    case 'top':
                        return { x: node.x + width / 2, y: node.y };
                    case 'right':
                        return { x: node.x + width, y: node.y + height / 2 };
                    case 'bottom':
                        return { x: node.x + width / 2, y: node.y + height };
                    case 'left':
                        return { x: node.x, y: node.y + height / 2 };
                    default:
                        return { x: node.x + width / 2, y: node.y + height / 2 };
                }
            }
            
            deleteConnection(connectionId) {
                const path = document.getElementById(`connection_${connectionId}`);
                if (path) path.remove();
                this.connections.delete(connectionId);
                this.saveState();
                this.saveToLocal();
            }
            
            selectNode(nodeId) {
                this.deselectAll();
                
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    this.selectedNode = nodeId;
                }
            }
            
            deleteNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return;
                
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) nodeEl.remove();
                
                const toRemove = [];
                this.connections.forEach((connection, id) => {
                    if (connection.from === nodeId || connection.to === nodeId) {
                        toRemove.push(id);
                        const pathEl = document.getElementById(`connection_${id}`);
                        if (pathEl) pathEl.remove();
                    }
                });
                
                toRemove.forEach(id => this.connections.delete(id));
                this.nodes.delete(nodeId);
                this.selectedNode = null;
                this.saveState();
                this.saveToLocal();
                this.updateOutline();
                this.showToast('🗑️', '노드 삭제됨');
            }
            
            addNode(parentId = null) {
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: '새 아이디어',
                    x: 5000 + Math.random() * 200 - 100,
                    y: 5000 + Math.random() * 200 - 100,
                    level: parentId ? (this.nodes.get(parentId)?.level || 0) + 1 : 1,
                    customColor: null
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                
                if (parentId && this.nodes.has(parentId)) {
                    this.createConnection(parentId, newNode.id, 'right', 'left');
                }
                
                this.selectNode(newNode.id);
                this.saveState();
                this.saveToLocal();
                this.updateOutline();
                
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addChildNode(parentId) {
                if (!parentId) parentId = this.selectedNode;
                if (!parentId) return;
                
                const parent = this.nodes.get(parentId);
                if (!parent) return;
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 180;
                
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: '새 아이디어',
                    x: parent.x + Math.cos(angle) * distance,
                    y: parent.y + Math.sin(angle) * distance,
                    level: parent.level + 1,
                    customColor: null
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                this.createConnection(parentId, newNode.id, 'right', 'left');
                this.selectNode(newNode.id);
                this.saveState();
                this.saveToLocal();
                this.updateOutline();
                
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addSiblingNode(nodeId) {
                if (!nodeId) nodeId = this.selectedNode;
                if (!nodeId) return;
                
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return;
                
                let parentId = null;
                this.connections.forEach(connection => {
                    if (connection.to === nodeId) {
                        parentId = connection.from;
                    }
                });
                
                if (parentId) {
                    this.addChildNode(parentId);
                }
            }
            
            centerView() {
                if (this.nodes.size === 0) return;
                
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                this.viewOffset.x = window.innerWidth / 2 - centerX;
                this.viewOffset.y = window.innerHeight / 2 - centerY;
                
                this.updateView();
            }
            
            updateView() {
                const transform = `translate(${this.viewOffset.x}px, ${this.viewOffset.y}px) scale(${this.zoom})`;
                this.canvas.style.transform = transform;
                this.nodesContainer.style.transform = transform;
            }
            
            zoomIn() {
                this.zoom = Math.min(2, this.zoom * 1.2);
                this.updateView();
            }
            
            zoomOut() {
                this.zoom = Math.max(0.3, this.zoom / 1.2);
                this.updateView();
            }
            
            resetZoom() {
                this.zoom = 1;
                this.updateView();
            }
            
            saveToLocal() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter
                };
                localStorage.setItem('mindMapProData', JSON.stringify(data));
            }
            
            loadFromLocal() {
                const savedData = localStorage.getItem('mindMapProData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        
                        data.nodes?.forEach(node => {
                            this.nodes.set(node.id, node);
                            this.renderNode(node);
                        });
                        
                        data.connections?.forEach(conn => {
                            this.connections.set(conn.id, {
                                from: conn.from,
                                to: conn.to,
                                fromPos: conn.fromPos || 'right',
                                toPos: conn.toPos || 'left'
                            });
                            this.renderConnection(conn.id);
                        });
                        
                        this.nodeIdCounter = data.nodeIdCounter || 0;
                        this.saveState();
                    } catch (e) {
                        console.error('Failed to load:', e);
                    }
                }
            }
            
            exportData() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-pro-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
                this.showToast('📤', '내보내기 완료');
            }
            
            clearAll(confirm = true) {
                if (confirm && !window.confirm('모든 내용이 삭제됩니다. 계속하시겠습니까?')) {
                    return;
                }
                
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                this.nodes.clear();
                this.connections.clear();
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                this.history = [];
                this.historyIndex = -1;
                
                this.createRootNode();
                this.saveToLocal();
                this.updateOutline();
                this.centerView();
                this.showToast('🗑️', '초기화 완료');
            }
        }
        
        // Initialize
        const mindMap = new MindMapPro();
    </script>
</body>
</html>