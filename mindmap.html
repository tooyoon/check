<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow - Ïä§ÎßàÌä∏ ÎßàÏù∏ÎìúÎßµ</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="mindmap-styles.css">
    <style>
        * {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }
        
        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #mindmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
        }
        
        #mindmap-canvas.panning {
            cursor: grabbing;
        }
        
        .node {
            position: absolute;
            padding: 12px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            transition: transform 0.2s, box-shadow 0.2s;
            z-index: 10;
            user-select: none;
            min-width: 120px;
            text-align: center;
            border: 2px solid transparent;
        }
        
        .node:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
            transform: scale(1.02);
        }
        
        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
        
        .node.root {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
            font-size: 18px;
            padding: 16px 24px;
        }
        
        .node.level-1 {
            background: linear-gradient(135deg, #10b981 0%, #14b8a6 100%);
            color: white;
            font-weight: 500;
        }
        
        .node.level-2 {
            background: linear-gradient(135deg, #f59e0b 0%, #fb923c 100%);
            color: white;
        }
        
        .node-text {
            outline: none;
            background: transparent;
            border: none;
            width: 100%;
            text-align: center;
            font-size: 14px;
        }
        
        .node.root .node-text {
            font-size: 18px;
        }
        
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 15;
        }
        
        .node:hover .connection-point {
            opacity: 1;
        }
        
        .connection-point.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            z-index: 20;
            border: 2px solid white;
        }
        
        .node:hover .delete-btn {
            display: flex;
        }
        
        .toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 16px;
            padding: 12px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 8px;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .toolbar-btn {
            padding: 8px 16px;
            border-radius: 8px;
            background: white;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .sidebar-nav {
            position: fixed;
            left: 20px;
            top: 20px;
            background: white;
            border-radius: 16px;
            padding: 12px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            z-index: 100;
        }
        
        .nav-btn {
            padding: 10px 20px;
            border-radius: 8px;
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }
        
        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }
        
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            border-radius: 12px;
            padding: 8px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 100;
        }
        
        .zoom-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            background: white;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: #f3f4f6;
        }
        
        .minimap {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow: hidden;
            border: 2px solid #e5e7eb;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- Navigation to TodoMaster -->
    <div class="sidebar-nav">
        <a href="todomaster_complete.html" class="nav-btn">
            <span>üìã</span>
            <span>Todo List</span>
        </a>
    </div>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <button class="toolbar-btn" onclick="mindMap.addNode()">
            <span>‚ûï</span>
            <span>ÎÖ∏Îìú Ï∂îÍ∞Ä</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.centerView()">
            <span>üéØ</span>
            <span>Ï§ëÏïô Ï†ïÎ†¨</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.saveToLocal()">
            <span>üíæ</span>
            <span>Ï†ÄÏû•</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.exportData()">
            <span>üì§</span>
            <span>ÎÇ¥Î≥¥ÎÇ¥Í∏∞</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.importData()">
            <span>üì•</span>
            <span>Í∞ÄÏ†∏Ïò§Í∏∞</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.clearAll()">
            <span>üóëÔ∏è</span>
            <span>Ï¥àÍ∏∞Ìôî</span>
        </button>
    </div>
    
    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="mindMap.zoomIn()">
            <span>‚ûï</span>
        </button>
        <button class="zoom-btn" onclick="mindMap.resetZoom()">
            <span>‚ü≤</span>
        </button>
        <button class="zoom-btn" onclick="mindMap.zoomOut()">
            <span>‚ûñ</span>
        </button>
    </div>
    
    <!-- Minimap -->
    <div class="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <!-- Main Canvas Container -->
    <div id="canvas-container">
        <svg id="mindmap-canvas" width="5000" height="5000">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#6b7280" />
                </marker>
            </defs>
            <g id="connections"></g>
        </svg>
        <div id="nodes-container"></div>
    </div>
    
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <script>
        class MindMap {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.selectedNode = null;
                this.draggedNode = null;
                this.connectionStart = null;
                this.isDraggingConnection = false;
                this.panStart = null;
                this.viewOffset = { x: 0, y: 0 };
                this.zoom = 1;
                this.nodeIdCounter = 0;
                this.canvas = document.getElementById('mindmap-canvas');
                this.container = document.getElementById('canvas-container');
                this.nodesContainer = document.getElementById('nodes-container');
                this.connectionsGroup = document.getElementById('connections');
                this.minimapCanvas = document.getElementById('minimap-canvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                
                this.init();
            }
            
            init() {
                // Load saved data
                this.loadFromLocal();
                
                // If no saved data, create root node
                if (this.nodes.size === 0) {
                    this.createRootNode();
                }
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Center view
                setTimeout(() => this.centerView(), 100);
                
                // Update minimap
                this.updateMinimap();
            }
            
            createRootNode() {
                const rootNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'Ï§ëÏã¨ ÏïÑÏù¥ÎîîÏñ¥',
                    x: 2500,
                    y: 2500,
                    level: 0,
                    color: null
                };
                this.nodes.set(rootNode.id, rootNode);
                this.renderNode(rootNode);
            }
            
            setupEventListeners() {
                // Canvas panning
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.target === this.canvas && !this.isDraggingConnection) {
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.canvas.classList.add('panning');
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.panStart && !this.isDraggingConnection) {
                        const dx = e.clientX - this.panStart.x;
                        const dy = e.clientY - this.panStart.y;
                        this.viewOffset.x += dx;
                        this.viewOffset.y += dy;
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.updateView();
                    }
                    
                    if (this.isDraggingConnection && this.connectionStart) {
                        this.updateTempConnection(e);
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    this.panStart = null;
                    this.canvas.classList.remove('panning');
                    
                    if (this.isDraggingConnection && this.connectionStart) {
                        // Check if mouse is over a connection point
                        const element = document.elementFromPoint(e.clientX, e.clientY);
                        if (!element || !element.classList.contains('connection-point')) {
                            this.removeTempConnection();
                        }
                        this.isDraggingConnection = false;
                        this.connectionStart = null;
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Delete' && this.selectedNode) {
                        this.deleteNode(this.selectedNode);
                    }
                    if (e.key === 'Tab' && this.selectedNode) {
                        e.preventDefault();
                        this.addChildNode(this.selectedNode);
                    }
                    if (e.key === 'Enter' && this.selectedNode) {
                        e.preventDefault();
                        this.addSiblingNode(this.selectedNode);
                    }
                });
            }
            
            renderNode(nodeData) {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                nodeEl.id = nodeData.id;
                nodeEl.style.left = nodeData.x + 'px';
                nodeEl.style.top = nodeData.y + 'px';
                
                // Add level class
                if (nodeData.level === 0) {
                    nodeEl.classList.add('root');
                } else if (nodeData.level === 1) {
                    nodeEl.classList.add('level-1');
                } else if (nodeData.level === 2) {
                    nodeEl.classList.add('level-2');
                }
                
                // Node text
                const textEl = document.createElement('input');
                textEl.className = 'node-text';
                textEl.value = nodeData.text;
                textEl.addEventListener('input', (e) => {
                    nodeData.text = e.target.value;
                    this.saveToLocal();
                });
                textEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectNode(nodeData.id);
                });
                nodeEl.appendChild(textEl);
                
                // Connection points
                ['top', 'right', 'bottom', 'left'].forEach(pos => {
                    const point = document.createElement('div');
                    point.className = `connection-point ${pos}`;
                    point.dataset.nodeId = nodeData.id;
                    point.dataset.position = pos;
                    
                    point.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startConnection(nodeData.id, pos, e);
                    });
                    
                    point.addEventListener('mouseenter', (e) => {
                        if (this.isDraggingConnection && this.connectionStart && this.connectionStart.nodeId !== nodeData.id) {
                            e.target.style.transform = 'scale(1.5)';
                            e.target.style.background = '#10b981';
                        }
                    });
                    
                    point.addEventListener('mouseleave', (e) => {
                        e.target.style.transform = '';
                        e.target.style.background = '';
                    });
                    
                    point.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (this.isDraggingConnection && this.connectionStart && this.connectionStart.nodeId !== nodeData.id) {
                            this.completeConnection(nodeData.id, pos);
                        }
                    });
                    
                    nodeEl.appendChild(point);
                });
                
                // Delete button
                if (nodeData.level !== 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '‚úï';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteNode(nodeData.id);
                    });
                    nodeEl.appendChild(deleteBtn);
                }
                
                // Drag functionality
                nodeEl.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('connection-point') || e.target.classList.contains('delete-btn')) return;
                    if (!this.isDraggingConnection) {
                        this.draggedNode = nodeData;
                        this.dragOffset = {
                            x: e.clientX - nodeData.x - this.viewOffset.x,
                            y: e.clientY - nodeData.y - this.viewOffset.y
                        };
                        this.selectNode(nodeData.id);
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.draggedNode && !this.isDraggingConnection) {
                        this.draggedNode.x = e.clientX - this.dragOffset.x - this.viewOffset.x;
                        this.draggedNode.y = e.clientY - this.dragOffset.y - this.viewOffset.y;
                        const nodeEl = document.getElementById(this.draggedNode.id);
                        if (nodeEl) {
                            nodeEl.style.left = this.draggedNode.x + 'px';
                            nodeEl.style.top = this.draggedNode.y + 'px';
                            this.updateConnections();
                        }
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    if (this.draggedNode && !this.isDraggingConnection) {
                        this.draggedNode = null;
                        this.saveToLocal();
                        this.updateMinimap();
                    }
                });
                
                this.nodesContainer.appendChild(nodeEl);
            }
            
            startConnection(nodeId, position, event) {
                this.connectionStart = { nodeId, position };
                this.isDraggingConnection = true;
                
                // Create temp connection line
                const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                tempPath.id = 'temp-connection';
                tempPath.setAttribute('fill', 'none');
                tempPath.setAttribute('stroke', '#3b82f6');
                tempPath.setAttribute('stroke-width', '3');
                tempPath.setAttribute('stroke-dasharray', '5,5');
                tempPath.style.pointerEvents = 'none';
                this.connectionsGroup.appendChild(tempPath);
                
                // Initial update
                this.updateTempConnection(event);
            }
            
            updateTempConnection(e) {
                const tempPath = document.getElementById('temp-connection');
                if (!tempPath || !this.connectionStart) return;
                
                const startNode = this.nodes.get(this.connectionStart.nodeId);
                if (!startNode) return;
                
                const startPoint = this.getConnectionPoint(startNode, this.connectionStart.position);
                const endX = e.clientX - this.viewOffset.x;
                const endY = e.clientY - this.viewOffset.y;
                
                // Create curved path
                const dx = endX - startPoint.x;
                const dy = endY - startPoint.y;
                const cx = startPoint.x + dx * 0.5;
                
                const d = `M ${startPoint.x} ${startPoint.y} Q ${cx} ${startPoint.y}, ${endX} ${endY}`;
                tempPath.setAttribute('d', d);
            }
            
            removeTempConnection() {
                const tempPath = document.getElementById('temp-connection');
                if (tempPath) {
                    tempPath.remove();
                }
            }
            
            completeConnection(targetNodeId, targetPosition) {
                if (!this.connectionStart) return;
                
                this.removeTempConnection();
                
                const connectionId = `${this.connectionStart.nodeId}_${targetNodeId}`;
                const reverseConnectionId = `${targetNodeId}_${this.connectionStart.nodeId}`;
                
                // Check if connection already exists or connecting to self
                if (this.connectionStart.nodeId === targetNodeId) {
                    return;
                }
                
                if (this.connections.has(connectionId) || this.connections.has(reverseConnectionId)) {
                    return;
                }
                
                this.connections.set(connectionId, {
                    from: this.connectionStart.nodeId,
                    to: targetNodeId,
                    fromPos: this.connectionStart.position,
                    toPos: targetPosition
                });
                
                this.renderConnection(connectionId);
                this.saveToLocal();
                this.updateMinimap();
            }
            
            renderConnection(connectionId) {
                const connection = this.connections.get(connectionId);
                if (!connection) return;
                
                const fromNode = this.nodes.get(connection.from);
                const toNode = this.nodes.get(connection.to);
                if (!fromNode || !toNode) return;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `connection_${connectionId}`;
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#6b7280');
                path.setAttribute('stroke-width', '2');
                path.style.pointerEvents = 'stroke';
                path.style.cursor = 'pointer';
                
                // Add hover effect
                path.addEventListener('mouseenter', () => {
                    path.setAttribute('stroke', '#ef4444');
                    path.setAttribute('stroke-width', '3');
                });
                
                path.addEventListener('mouseleave', () => {
                    path.setAttribute('stroke', '#6b7280');
                    path.setAttribute('stroke-width', '2');
                });
                
                // Add click to delete
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('Ïù¥ Ïó∞Í≤∞ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                        this.deleteConnection(connectionId);
                    }
                });
                
                this.updateConnectionPath(path, fromNode, toNode, connection);
                this.connectionsGroup.appendChild(path);
            }
            
            updateConnectionPath(path, fromNode, toNode, connection) {
                const fromPos = connection?.fromPos || 'right';
                const toPos = connection?.toPos || 'left';
                
                const fromPoint = this.getConnectionPoint(fromNode, fromPos);
                const toPoint = this.getConnectionPoint(toNode, toPos);
                
                // Create curved path
                const dx = toPoint.x - fromPoint.x;
                const dy = toPoint.y - fromPoint.y;
                
                // Control points for bezier curve
                let cx1, cy1, cx2, cy2;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal connection
                    cx1 = fromPoint.x + dx * 0.5;
                    cy1 = fromPoint.y;
                    cx2 = fromPoint.x + dx * 0.5;
                    cy2 = toPoint.y;
                } else {
                    // Vertical connection
                    cx1 = fromPoint.x;
                    cy1 = fromPoint.y + dy * 0.5;
                    cx2 = toPoint.x;
                    cy2 = fromPoint.y + dy * 0.5;
                }
                
                const d = `M ${fromPoint.x} ${fromPoint.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${toPoint.x} ${toPoint.y}`;
                path.setAttribute('d', d);
            }
            
            updateConnections() {
                this.connections.forEach((connection, id) => {
                    const path = document.getElementById(`connection_${id}`);
                    if (path) {
                        const fromNode = this.nodes.get(connection.from);
                        const toNode = this.nodes.get(connection.to);
                        if (fromNode && toNode) {
                            this.updateConnectionPath(path, fromNode, toNode, connection);
                        }
                    }
                });
            }
            
            deleteConnection(connectionId) {
                const path = document.getElementById(`connection_${connectionId}`);
                if (path) {
                    path.remove();
                }
                this.connections.delete(connectionId);
                this.saveToLocal();
                this.updateMinimap();
            }
            
            getConnectionPoint(node, position) {
                const nodeEl = document.getElementById(node.id);
                if (!nodeEl) return { x: node.x + 60, y: node.y + 25 };
                
                const rect = nodeEl.getBoundingClientRect();
                const width = rect.width / this.zoom;
                const height = rect.height / this.zoom;
                
                switch(position) {
                    case 'top':
                        return { x: node.x + width / 2, y: node.y };
                    case 'right':
                        return { x: node.x + width, y: node.y + height / 2 };
                    case 'bottom':
                        return { x: node.x + width / 2, y: node.y + height };
                    case 'left':
                        return { x: node.x, y: node.y + height / 2 };
                    default:
                        return { x: node.x + width / 2, y: node.y + height / 2 };
                }
            }
            
            selectNode(nodeId) {
                // Remove previous selection
                document.querySelectorAll('.node.selected').forEach(node => {
                    node.classList.remove('selected');
                });
                
                // Add selection to current node
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    this.selectedNode = nodeId;
                }
            }
            
            deleteNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return; // Don't delete root
                
                // Remove node element
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) nodeEl.remove();
                
                // Remove connections
                const connectionsToRemove = [];
                this.connections.forEach((connection, id) => {
                    if (connection.from === nodeId || connection.to === nodeId) {
                        connectionsToRemove.push(id);
                        const pathEl = document.getElementById(`connection_${id}`);
                        if (pathEl) pathEl.remove();
                    }
                });
                
                connectionsToRemove.forEach(id => this.connections.delete(id));
                
                // Remove node
                this.nodes.delete(nodeId);
                this.selectedNode = null;
                this.saveToLocal();
                this.updateMinimap();
            }
            
            addNode(parentId = null) {
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                    x: 2500 + Math.random() * 200 - 100,
                    y: 2500 + Math.random() * 200 - 100,
                    level: parentId ? (this.nodes.get(parentId)?.level || 0) + 1 : 1,
                    color: null
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                
                // Auto connect to parent if provided
                if (parentId && this.nodes.has(parentId)) {
                    const connectionId = `${parentId}_${newNode.id}`;
                    this.connections.set(connectionId, {
                        from: parentId,
                        to: newNode.id
                    });
                    this.renderConnection(connectionId);
                }
                
                this.selectNode(newNode.id);
                this.saveToLocal();
                this.updateMinimap();
                
                // Focus on text input
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addChildNode(parentId) {
                if (!parentId) parentId = this.selectedNode;
                if (!parentId) return;
                
                const parent = this.nodes.get(parentId);
                if (!parent) return;
                
                // Calculate position for child
                const angle = Math.random() * Math.PI * 2;
                const distance = 150;
                
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                    x: parent.x + Math.cos(angle) * distance,
                    y: parent.y + Math.sin(angle) * distance,
                    level: parent.level + 1,
                    color: null
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                
                // Connect to parent
                const connectionId = `${parentId}_${newNode.id}`;
                this.connections.set(connectionId, {
                    from: parentId,
                    to: newNode.id
                });
                this.renderConnection(connectionId);
                
                this.selectNode(newNode.id);
                this.saveToLocal();
                this.updateMinimap();
                
                // Focus on text input
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addSiblingNode(nodeId) {
                if (!nodeId) nodeId = this.selectedNode;
                if (!nodeId) return;
                
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return;
                
                // Find parent connection
                let parentId = null;
                this.connections.forEach(connection => {
                    if (connection.to === nodeId) {
                        parentId = connection.from;
                    }
                });
                
                if (parentId) {
                    this.addChildNode(parentId);
                } else {
                    // If no parent, just add a node at the same level
                    const newNode = {
                        id: 'node_' + this.nodeIdCounter++,
                        text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                        x: node.x + 150,
                        y: node.y,
                        level: node.level,
                        color: null
                    };
                    
                    this.nodes.set(newNode.id, newNode);
                    this.renderNode(newNode);
                    this.selectNode(newNode.id);
                    this.saveToLocal();
                    this.updateMinimap();
                }
            }
            
            centerView() {
                if (this.nodes.size === 0) return;
                
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                this.viewOffset.x = window.innerWidth / 2 - centerX;
                this.viewOffset.y = window.innerHeight / 2 - centerY;
                
                this.updateView();
            }
            
            updateView() {
                this.canvas.style.transform = `translate(${this.viewOffset.x}px, ${this.viewOffset.y}px) scale(${this.zoom})`;
                this.nodesContainer.style.transform = `translate(${this.viewOffset.x}px, ${this.viewOffset.y}px) scale(${this.zoom})`;
            }
            
            zoomIn() {
                this.zoom = Math.min(2, this.zoom * 1.2);
                this.updateView();
            }
            
            zoomOut() {
                this.zoom = Math.max(0.5, this.zoom / 1.2);
                this.updateView();
            }
            
            resetZoom() {
                this.zoom = 1;
                this.updateView();
            }
            
            updateMinimap() {
                const canvas = this.minimapCanvas;
                const ctx = this.minimapCtx;
                const scale = 0.02;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                this.connections.forEach(connection => {
                    const fromNode = this.nodes.get(connection.from);
                    const toNode = this.nodes.get(connection.to);
                    if (fromNode && toNode) {
                        ctx.beginPath();
                        ctx.moveTo(fromNode.x * scale, fromNode.y * scale);
                        ctx.lineTo(toNode.x * scale, toNode.y * scale);
                        ctx.stroke();
                    }
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    ctx.fillStyle = node.level === 0 ? '#3b82f6' : '#6b7280';
                    ctx.fillRect(
                        node.x * scale - 2,
                        node.y * scale - 2,
                        4,
                        4
                    );
                });
            }
            
            saveToLocal() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter
                };
                localStorage.setItem('mindMapData', JSON.stringify(data));
            }
            
            loadFromLocal() {
                const savedData = localStorage.getItem('mindMapData');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        
                        // Load nodes
                        data.nodes.forEach(node => {
                            this.nodes.set(node.id, node);
                            this.renderNode(node);
                        });
                        
                        // Load connections
                        data.connections.forEach(conn => {
                            this.connections.set(conn.id, {
                                from: conn.from,
                                to: conn.to
                            });
                            this.renderConnection(conn.id);
                        });
                        
                        this.nodeIdCounter = data.nodeIdCounter || 0;
                    } catch (e) {
                        console.error('Failed to load saved data:', e);
                    }
                }
            }
            
            exportData() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            importData() {
                const input = document.getElementById('file-input');
                input.click();
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                this.clearAll(false);
                                
                                // Load nodes
                                data.nodes.forEach(node => {
                                    this.nodes.set(node.id, node);
                                    this.renderNode(node);
                                });
                                
                                // Load connections
                                data.connections.forEach(conn => {
                                    this.connections.set(conn.id, {
                                        from: conn.from,
                                        to: conn.to
                                    });
                                    this.renderConnection(conn.id);
                                });
                                
                                this.nodeIdCounter = data.nodeIdCounter || 0;
                                this.saveToLocal();
                                this.updateMinimap();
                                this.centerView();
                            } catch (err) {
                                alert('ÌååÏùºÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
            }
            
            clearAll(confirm = true) {
                if (confirm && !window.confirm('Î™®Îì† ÎÇ¥Ïö©Ïù¥ ÏÇ≠Ï†úÎê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                    return;
                }
                
                // Clear DOM
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                
                // Clear data
                this.nodes.clear();
                this.connections.clear();
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                
                // Create new root
                this.createRootNode();
                this.saveToLocal();
                this.updateMinimap();
                this.centerView();
            }
        }
        
        // Initialize MindMap
        const mindMap = new MindMap();
    </script>
</body>
</html>