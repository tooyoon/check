<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow - Ïä§ÎßàÌä∏ ÎßàÏù∏ÎìúÎßµ</title>
    <link rel="stylesheet" href="shared-design-system.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config-v2.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">
    <style>
        
        * {
            font-family: 'Inter', sans-serif;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }
        
        /* Glassmorphism effect */
        .glassmorphism {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Card hover effect */
        .card-hover {
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            will-change: transform, box-shadow;
        }
        
        .card-hover:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        /* Category active state */
        .category-active {
            background: linear-gradient(135deg, #a855f7 0%, #ec4899 100%);
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(168, 85, 247, 0.3);
        }
        
        /* Authentication Styles */
        .auth-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease;
        }

        .auth-modal {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideUp 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .sync-indicator {
            position: fixed;
            bottom: 20px;
            left: 280px;
            padding: 8px 16px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            z-index: 100;
            transition: all 0.3s ease;
        }

        .sync-indicator.syncing {
            background: #fbbf24;
            color: white;
        }

        .sync-indicator.synced {
            background: #10b981;
            color: white;
        }

        .sync-indicator.offline {
            background: #ef4444;
            color: white;
        }

        .user-profile-button {
            position: relative;
            cursor: pointer;
        }

        .user-dropdown {
            position: absolute;
            top: calc(100% + 0.5rem);
            right: 0;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            padding: 0.5rem;
            min-width: 200px;
            z-index: 50;
            display: none;
        }

        .user-dropdown.show {
            display: block;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from { transform: translateY(-10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        
        #mindmap-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: grab;
        }
        
        #mindmap-canvas.panning {
            cursor: grabbing;
        }
        
        .node {
            position: absolute;
            padding: 12px 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: move;
            transition: box-shadow 0.2s, border-color 0.2s;
            z-index: 10;
            user-select: none;
            min-width: 120px;
            text-align: center;
            border: 2px solid transparent;
            overflow: visible;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Hover state - subtle glow */
        .node:hover {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.12);
            border-color: rgba(59, 130, 246, 0.3);
        }
        
        /* Selected state */
        .node.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
            z-index: 15;
        }
        
        /* Multi-selected state */
        .node.multi-selected {
            border-color: #8b5cf6;
            border-width: 3px;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.4);
        }
        
        .selection-box {
            position: absolute;
            border: 2px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            z-index: 100;
        }
        
        .node.root {
            background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
            color: white;
            font-weight: 600;
            font-size: 18px;
            padding: 16px 24px;
        }
        
        .node.level-1 {
            background: linear-gradient(135deg, #10b981 0%, #14b8a6 100%);
            color: white;
            font-weight: 500;
        }
        
        .node.level-2 {
            background: linear-gradient(135deg, #f59e0b 0%, #fb923c 100%);
            color: white;
        }
        
        .node-text {
            outline: none;
            background: transparent;
            border: none;
            width: 100%;
            text-align: center;
            font-size: 14px;
            white-space: pre-wrap;
            min-height: 20px;
            display: block;
            resize: none;
            padding: 4px 2px;
            vertical-align: middle;
        }
        
        .node-text.align-left {
            text-align: left;
        }
        
        .node-text.align-center {
            text-align: center;
        }
        
        .node-text.align-right {
            text-align: right;
        }
        
        .node.root .node-text {
            font-size: 18px;
        }
        
        .connection-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 15;
        }
        
        .node:hover .connection-point {
            opacity: 1;
        }
        
        .connection-point.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.left {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .connection-point.top {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .connection-point.bottom {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .delete-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            z-index: 20;
            border: 2px solid white;
        }
        
        .node:hover .delete-btn {
            display: flex;
        }
        
        /* Simple resize handle - bottom right corner */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 16px;
            height: 16px;
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 21;
        }
        
        .resize-handle::after {
            content: '';
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 10px;
            height: 10px;
            background: linear-gradient(135deg, transparent 50%, #3b82f6 50%);
            border-radius: 0 0 2px 0;
        }
        
        .node:hover .resize-handle {
            opacity: 0.5;
        }
        
        .resize-handle:hover {
            opacity: 1 !important;
        }
        
        /* Color Palette */
        .color-palette {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            gap: 4px;
            z-index: 30;
        }
        
        .node:hover .color-palette {
            display: flex;
        }
        
        /* Text Alignment Controls - at the top */
        .text-align-controls {
            position: absolute;
            top: -120px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            gap: 2px;
            z-index: 30;
        }
        
        .node:hover .text-align-controls {
            display: flex;
        }
        
        .align-btn {
            width: 32px;
            height: 28px;
            border-radius: 4px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #374151;
            transition: all 0.2s;
        }
        
        .align-btn:hover {
            background: #e5e7eb;
            transform: scale(1.05);
        }
        
        .align-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* Font Size Controls - now below text alignment */
        .font-size-controls {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            border-radius: 8px;
            padding: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: none;
            gap: 4px;
            z-index: 30;
            align-items: center;
        }
        
        .node:hover .font-size-controls {
            display: flex;
        }
        
        .font-size-btn {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: #374151;
            transition: all 0.2s;
        }
        
        .font-size-btn:hover {
            background: #3b82f6;
            color: white;
            transform: scale(1.1);
        }
        
        .font-size-display {
            padding: 0 8px;
            font-size: 12px;
            color: #6b7280;
            min-width: 30px;
            text-align: center;
        }
        
        .color-btn {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            cursor: pointer;
            border: 2px solid white;
            transition: transform 0.2s;
        }
        
        .color-btn:hover {
            transform: scale(1.2);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .toolbar {
            position: fixed;
            top: 1.25rem;
            left: calc(20rem + 50%);
            transform: translateX(-50%);
            border-radius: 1rem;
            padding: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            gap: 0.5rem;
            z-index: 100;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .toolbar-btn {
            padding: 0.625rem 1rem;
            border-radius: 0.75rem;
            background: white;
            border: 1px solid rgba(226, 232, 240, 0.8);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #475569;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .toolbar-btn:hover {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
            border-color: transparent;
        }
        
        .toolbar-btn span:first-child {
            font-size: 1.125rem;
        }
        
        .sidebar-nav {
            width: 20rem;
            position: fixed;
            left: 0;
            top: 0;
            height: 100vh;
            background: linear-gradient(180deg, #f8fafc 0%, #f1f5f9 100%);
            border-right: 1px solid rgba(226, 232, 240, 0.8);
            overflow-y: auto;
            z-index: 10;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        
        /* Main content adjustment */
        #canvas-container {
            margin-left: 20rem;
        }
        
        /* Progress glow effect */
        .progress-glow {
            box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
        }
        
        /* Fade in animation */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .nav-btn {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .nav-btn:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }
        
        .nav-btn span:first-child {
            font-size: 1.125rem;
        }
        
        .boards-section {
            border-top: 1px solid rgba(226, 232, 240, 0.5);
            padding-top: 0.75rem;
            margin-top: 0.75rem;
        }
        
        .boards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding: 0 0.25rem;
        }
        
        .boards-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .add-board-btn {
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.5rem;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 1rem;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        
        .add-board-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .boards-list {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            max-height: 20rem;
            overflow-y: auto;
        }
        
        .board-item {
            padding: 0.625rem 0.75rem;
            border-radius: 0.625rem;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: #475569;
            border: 1px solid transparent;
        }
        
        .board-item:hover {
            background: #f8fafc;
            transform: translateX(2px);
        }
        
        .board-item.active {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            transform: scale(1.02);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }
        
        .board-item-icon {
            margin-right: 0.5rem;
            opacity: 0.7;
        }
        
        .board-delete {
            opacity: 0;
            transition: opacity 0.2s ease;
            cursor: pointer;
            padding: 0.125rem;
            font-size: 1rem;
        }
        
        .board-item:hover .board-delete {
            opacity: 0.7;
        }
        
        .board-item.active .board-delete {
            opacity: 0.9;
        }
        
        .board-delete:hover {
            opacity: 1 !important;
            transform: scale(1.1);
        }
        
        /* Bottom right controls container */
        .bottom-controls {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
            z-index: 100;
        }
        
        .minimap {
            width: 12rem;
            height: 9rem;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            border: 1px solid rgba(226, 232, 240, 0.8);
            position: relative;
        }
        
        .minimap-label {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            font-size: 0.625rem;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: rgba(255, 255, 255, 0.8);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
        }
        
        .zoom-controls {
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(226, 232, 240, 0.8);
            border-radius: 0.75rem;
            padding: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .zoom-btn {
            min-width: 2.25rem;
            height: 2.25rem;
            padding: 0 0.5rem;
            border-radius: 0.5rem;
            background: white;
            border: 1px solid rgba(226, 232, 240, 0.8);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            font-weight: 600;
            color: #475569;
        }
        
        .zoom-btn:hover {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
            border-color: transparent;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <aside class="sidebar-nav">
        <!-- Header -->
        <div class="mb-8">
            <div class="flex items-center gap-3 mb-4">
                <div class="w-10 h-10 rounded-2xl bg-gradient-to-br from-purple-500 to-pink-600 flex items-center justify-center">
                    <span class="text-white text-lg font-bold">üß†</span>
                </div>
                <div>
                    <h1 class="text-xl font-bold text-gray-800">MindFlow</h1>
                    <p class="text-xs text-gray-500">Ïä§ÎßàÌä∏ ÎßàÏù∏ÎìúÎßµ</p>
                </div>
            </div>
            
            <!-- Stats Card -->
            <div class="glassmorphism rounded-2xl p-4 mb-4 fade-in">
                <div class="text-sm text-gray-600 mb-2">Ï†ÑÏ≤¥ ÌÜµÍ≥Ñ</div>
                <div class="text-2xl font-bold text-gray-800 mb-2" id="stats-display">
                    <span id="total-nodes">0</span>Í∞ú ÎÖ∏Îìú
                </div>
                <div class="text-xs text-gray-500 mb-2">
                    <span id="total-boards">0</span>Í∞ú Î≥¥Îìú Î≥¥Ïú†
                </div>
                <div class="w-full bg-gray-200 rounded-full h-3 mb-2">
                    <div id="progress-bar"
                        class="bg-gradient-to-r from-purple-500 to-pink-600 h-3 rounded-full transition-all duration-500 progress-glow"
                        style="width: 0%">
                    </div>
                </div>
                <div class="text-xs text-gray-500">
                    <span id="connections-count">0</span>Í∞ú Ïó∞Í≤∞
                </div>
            </div>
        </div>
        
        <!-- Boards Section -->
        <div class="mb-6">
            <div class="font-semibold mb-3 text-gray-700">üìÇ ÎßàÏù∏ÎìúÎßµ Î≥¥Îìú</div>
            <div class="space-y-2" id="boards-list">
                <!-- Board items will be added here -->
            </div>
            
            <!-- Add New Board -->
            <div class="mt-6 bg-white/60 backdrop-blur-sm rounded-2xl p-4 border border-gray-200/50">
                <div class="text-sm font-medium text-gray-700 mb-3 flex items-center gap-2">
                    <span>‚ûï</span>
                    ÏÉà Î≥¥Îìú Ï∂îÍ∞Ä
                </div>
                <div class="space-y-3">
                    <input
                        id="new-board-name"
                        type="text"
                        placeholder="Î≥¥Îìú Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                        onkeypress="if(event.key === 'Enter') { event.preventDefault(); const val = this.value.trim(); if(val) { mindMap.createNewBoard(val); this.value = ''; } }"
                        class="w-full px-4 py-3 border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent bg-white text-gray-800 placeholder-gray-500 form-input"
                    />
                    <button
                        onclick="const input = document.getElementById('new-board-name'); const val = input.value.trim(); if(val) { mindMap.createNewBoard(val); input.value = ''; }"
                        class="w-full px-4 py-3 rounded-xl bg-gradient-to-r from-purple-500 to-pink-600 text-white hover:from-purple-600 hover:to-pink-700 transform hover:scale-[1.02] transition-all duration-200 shadow-md font-medium flex items-center justify-center gap-2"
                    >
                        <span>‚ú®</span>
                        Ï∂îÍ∞ÄÌïòÍ∏∞
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Bottom Links -->
        <div class="space-y-2">
            <a href="index.html" 
               class="w-full px-4 py-3 text-left rounded-xl bg-gradient-to-r from-blue-500 to-indigo-600 text-white hover:from-blue-600 hover:to-indigo-700 flex items-center gap-2 transform hover:scale-[1.02] transition-all duration-200 shadow-md">
                üìã TodoMaster
            </a>
            <a href="feedback.html" 
               class="w-full px-4 py-3 text-left rounded-xl bg-gradient-to-r from-indigo-500 to-blue-500 text-white hover:from-indigo-600 hover:to-blue-600 flex items-center gap-2 transform hover:scale-[1.02] transition-all duration-200 shadow-md">
                üí¨ ÌîºÎìúÎ∞± Í≤åÏãúÌåê
            </a>
            <button onclick="mindMap.openSettings()"
                    class="w-full px-4 py-2 text-left rounded-xl hover:bg-gray-100 flex items-center gap-2">
                ‚öôÔ∏è ÏÑ§Ï†ï
            </button>
        </div>
    </aside>
    
    <!-- Toolbar -->
    <div class="toolbar">
        <button class="toolbar-btn" onclick="mindMap.addNode()" title="ÏÉà ÎÖ∏Îìú Ï∂îÍ∞Ä">
            <span>‚ûï</span>
            <span>Ï∂îÍ∞Ä</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.centerView()" title="ÌôîÎ©¥ Ï§ëÏïôÏúºÎ°ú">
            <span>üéØ</span>
            <span>Ï§ëÏïô</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.autoLayout()" title="ÏûêÎèôÏúºÎ°ú ÏòàÏÅòÍ≤å Ï†ïÎ†¨">
            <span>‚ú®</span>
            <span>Ï†ïÎ†¨</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.saveToLocal()" title="ÌòÑÏû¨ ÏÉÅÌÉú Ï†ÄÏû•">
            <span>üíæ</span>
            <span>Ï†ÄÏû•</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.exportData()" title="ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞">
            <span>üì§</span>
            <span>ÎÇ¥Î≥¥ÎÇ¥Í∏∞</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.importData()" title="ÌååÏùº Î∂àÎü¨Ïò§Í∏∞">
            <span>üì•</span>
            <span>Î∂àÎü¨Ïò§Í∏∞</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.clearAll()" title="Î™®Îëê ÏßÄÏö∞Í∏∞">
            <span>üóëÔ∏è</span>
            <span>Ï¥àÍ∏∞Ìôî</span>
        </button>
        <button class="toolbar-btn" onclick="mindMap.showHelp()" title="Îã®Ï∂ïÌÇ§ Î∞è ÏÇ¨Ïö©Î≤ï">
            <span>‚ùì</span>
            <span>ÎèÑÏõÄ</span>
        </button>
    </div>
    
    <!-- Bottom Right Controls Container -->
    <div class="bottom-controls">
        <!-- Minimap (on the left) -->
        <div class="minimap">
            <span class="minimap-label">ÎØ∏Î¶¨Î≥¥Í∏∞</span>
            <canvas id="minimap-canvas"></canvas>
        </div>
        
        <!-- Zoom Controls (on the right) -->
        <div class="zoom-controls">
            <button class="zoom-btn" onclick="mindMap.zoomIn()" title="ÌôïÎåÄ (+)">
                <span>+</span>
            </button>
            <button class="zoom-btn" onclick="mindMap.resetZoom()" title="Í∏∞Î≥∏ ÌÅ¨Í∏∞">
                <span>100%</span>
            </button>
            <button class="zoom-btn" onclick="mindMap.zoomOut()" title="Ï∂ïÏÜå (‚àí)">
                <span>‚àí</span>
            </button>
        </div>
    </div>
    
    <!-- Main Canvas Container -->
    <div id="canvas-container">
        <svg id="mindmap-canvas" width="5000" height="5000">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                        refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#6b7280" />
                </marker>
            </defs>
            <g id="connections"></g>
        </svg>
        <div id="nodes-container"></div>
    </div>
    
    <input type="file" id="file-input" accept=".json" style="display: none;">
    
    <script>
        class MindMap {
            constructor() {
                this.nodes = new Map();
                this.connections = new Map();
                this.selectedNode = null;
                this.selectedNodes = new Set();
                this.draggedNode = null;
                this.draggedNodes = [];
                this.connectionStart = null;
                this.isDraggingConnection = false;
                this.panStart = null;
                this.viewOffset = { x: 0, y: 0 };
                this.zoom = 1;
                this.nodeIdCounter = 0;
                this.canvas = document.getElementById('mindmap-canvas');
                this.container = document.getElementById('canvas-container');
                this.nodesContainer = document.getElementById('nodes-container');
                this.connectionsGroup = document.getElementById('connections');
                this.minimapCanvas = document.getElementById('minimap-canvas');
                this.minimapCtx = this.minimapCanvas.getContext('2d');
                
                // Undo/Redo history
                this.history = [];
                this.historyIndex = -1;
                this.maxHistory = 50;
                
                // Copy/Paste
                this.copiedNode = null;
                
                // Resize
                this.resizingNode = null;
                this.resizeStart = null;
                
                // Multi-select
                this.isSelecting = false;
                this.selectionStart = null;
                this.selectionBox = null;
                
                // Board management
                this.boards = new Map();
                this.currentBoardId = null;
                this.boardIdCounter = 0;
                
                this.init();
            }
            
            init() {
                // Load boards
                this.loadBoards();
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initialize with first board or create default
                if (this.boards.size === 0) {
                    this.createNewBoard('Î©îÏù∏ ÎßàÏù∏ÎìúÎßµ');
                } else {
                    const firstBoard = Array.from(this.boards.keys())[0];
                    this.switchBoard(firstBoard);
                }
                
                // Update UI
                this.updateBoardsList();
            }
            
            createRootNode() {
                const rootNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'Ï§ëÏã¨ ÏïÑÏù¥ÎîîÏñ¥',
                    x: 2500,
                    y: 2500,
                    level: 0,
                    color: null,
                    fontSize: 18
                };
                this.nodes.set(rootNode.id, rootNode);
                this.renderNode(rootNode);
                this.saveState();
            }
            
            setupEventListeners() {
                // Canvas panning and selection
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.target === this.canvas && !this.isDraggingConnection) {
                        // Check if shift is held for multi-select
                        if (e.shiftKey) {
                            this.startSelection(e);
                        } else {
                            this.panStart = { x: e.clientX, y: e.clientY };
                            this.canvas.classList.add('panning');
                        }
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isSelecting) {
                        this.updateSelection(e);
                    }
                    
                    if (this.panStart && !this.isDraggingConnection) {
                        const dx = e.clientX - this.panStart.x;
                        const dy = e.clientY - this.panStart.y;
                        this.viewOffset.x += dx;
                        this.viewOffset.y += dy;
                        this.panStart = { x: e.clientX, y: e.clientY };
                        this.updateView();
                    }
                    
                    if (this.isDraggingConnection && this.connectionStart) {
                        this.updateTempConnection(e);
                    }
                });
                
                document.addEventListener('mouseup', (e) => {
                    if (this.isSelecting) {
                        this.endSelection();
                    }
                    
                    this.panStart = null;
                    this.canvas.classList.remove('panning');
                    
                    if (this.isDraggingConnection && this.connectionStart) {
                        // Check if mouse is over a connection point
                        const element = document.elementFromPoint(e.clientX, e.clientY);
                        if (!element || !element.classList.contains('connection-point')) {
                            this.removeTempConnection();
                        }
                        this.isDraggingConnection = false;
                        this.connectionStart = null;
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ctrl/Cmd shortcuts
                    if (e.ctrlKey || e.metaKey) {
                        switch(e.key.toLowerCase()) {
                            case 'z':
                                e.preventDefault();
                                this.undo();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.redo();
                                break;
                            case 'c':
                                e.preventDefault();
                                this.copy();
                                break;
                            case 'v':
                                e.preventDefault();
                                this.paste();
                                break;
                            case 's':
                                e.preventDefault();
                                this.saveToLocal();
                                this.showToast('Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§');
                                break;
                        }
                    } else {
                        switch(e.key) {
                            case 'Delete':
                                if (this.selectedNode) {
                                    this.deleteNode(this.selectedNode);
                                }
                                break;
                            case 'Tab':
                                e.preventDefault();
                                if (this.selectedNode) {
                                    this.addSiblingNode(this.selectedNode);
                                }
                                break;
                            case 'Enter':
                                // Don't create new node if typing in text field
                                if (e.target.classList && e.target.classList.contains('node-text')) {
                                    // Allow default behavior for text input
                                    return;
                                }
                                e.preventDefault();
                                if (this.selectedNode) {
                                    this.addChildNode(this.selectedNode);
                                }
                                break;
                        }
                    }
                });
            }
            
            renderNode(nodeData) {
                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                nodeEl.id = nodeData.id;
                nodeEl.style.left = nodeData.x + 'px';
                nodeEl.style.top = nodeData.y + 'px';
                
                // Apply saved dimensions
                if (nodeData.width) {
                    nodeEl.style.width = nodeData.width + 'px';
                }
                if (nodeData.height) {
                    nodeEl.style.height = nodeData.height + 'px';
                }
                
                // Apply custom color or level class
                if (nodeData.customColor) {
                    nodeEl.style.background = nodeData.customColor;
                    nodeEl.style.color = 'white';
                } else {
                    // Add level class
                    if (nodeData.level === 0) {
                        nodeEl.classList.add('root');
                    } else if (nodeData.level === 1) {
                        nodeEl.classList.add('level-1');
                    } else if (nodeData.level === 2) {
                        nodeEl.classList.add('level-2');
                    }
                }
                
                // Node text (using textarea for multi-line support)
                const textEl = document.createElement('textarea');
                textEl.className = 'node-text';
                textEl.value = nodeData.text;
                // Apply saved font size or default
                if (!nodeData.fontSize) {
                    nodeData.fontSize = nodeData.level === 0 ? 18 : 14;
                }
                textEl.style.fontSize = nodeData.fontSize + 'px';
                
                // Apply saved text alignment or default to center
                if (!nodeData.textAlign) {
                    nodeData.textAlign = 'center';
                }
                textEl.classList.add(`align-${nodeData.textAlign}`);
                
                textEl.addEventListener('input', (e) => {
                    nodeData.text = e.target.value;
                    // Auto-resize textarea
                    textEl.style.height = 'auto';
                    textEl.style.height = textEl.scrollHeight + 'px';
                    this.saveToLocal();
                });
                textEl.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.selectNode(nodeData.id);
                });
                // Prevent Enter key from creating new node when editing text
                textEl.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.stopPropagation();
                    }
                });
                nodeEl.appendChild(textEl);
                
                // Auto-resize on load
                setTimeout(() => {
                    textEl.style.height = 'auto';
                    textEl.style.height = textEl.scrollHeight + 'px';
                }, 0);
                
                // Connection points
                ['top', 'right', 'bottom', 'left'].forEach(pos => {
                    const point = document.createElement('div');
                    point.className = `connection-point ${pos}`;
                    point.dataset.nodeId = nodeData.id;
                    point.dataset.position = pos;
                    
                    point.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        this.startConnection(nodeData.id, pos, e);
                    });
                    
                    point.addEventListener('mouseenter', (e) => {
                        if (this.isDraggingConnection && this.connectionStart && this.connectionStart.nodeId !== nodeData.id) {
                            e.target.style.transform = 'scale(1.5)';
                            e.target.style.background = '#10b981';
                        }
                    });
                    
                    point.addEventListener('mouseleave', (e) => {
                        e.target.style.transform = '';
                        e.target.style.background = '';
                    });
                    
                    point.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (this.isDraggingConnection && this.connectionStart && this.connectionStart.nodeId !== nodeData.id) {
                            this.completeConnection(nodeData.id, pos);
                        }
                    });
                    
                    nodeEl.appendChild(point);
                });
                
                // Text alignment controls (at the very top)
                const textAlignControls = document.createElement('div');
                textAlignControls.className = 'text-align-controls';
                
                const alignments = [
                    { value: 'left', icon: '‚óÄ', title: 'ÏôºÏ™Ω Ï†ïÎ†¨' },
                    { value: 'center', icon: '‚ñ†', title: 'Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨' },
                    { value: 'right', icon: '‚ñ∂', title: 'Ïò§Î•∏Ï™Ω Ï†ïÎ†¨' }
                ];
                
                alignments.forEach(align => {
                    const alignBtn = document.createElement('button');
                    alignBtn.className = 'align-btn';
                    if (nodeData.textAlign === align.value) {
                        alignBtn.classList.add('active');
                    }
                    alignBtn.textContent = align.icon;
                    alignBtn.title = align.title;
                    alignBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        nodeData.textAlign = align.value;
                        
                        // Update text element
                        textEl.classList.remove('align-left', 'align-center', 'align-right');
                        textEl.classList.add(`align-${align.value}`);
                        
                        // Update button states
                        textAlignControls.querySelectorAll('.align-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                        alignBtn.classList.add('active');
                        
                        this.saveState();
                        this.saveToLocal();
                    });
                    textAlignControls.appendChild(alignBtn);
                });
                
                nodeEl.appendChild(textAlignControls);
                
                // Font size controls (below text alignment)
                const fontSizeControls = document.createElement('div');
                fontSizeControls.className = 'font-size-controls';
                
                const decreaseBtn = document.createElement('button');
                decreaseBtn.className = 'font-size-btn';
                decreaseBtn.textContent = '‚àí';
                
                const fontSizeDisplay = document.createElement('span');
                fontSizeDisplay.className = 'font-size-display';
                fontSizeDisplay.textContent = nodeData.fontSize + 'px';
                
                const increaseBtn = document.createElement('button');
                increaseBtn.className = 'font-size-btn';
                increaseBtn.textContent = '+';
                
                decreaseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (nodeData.fontSize > 10) {
                        nodeData.fontSize -= 2;
                        textEl.style.fontSize = nodeData.fontSize + 'px';
                        fontSizeDisplay.textContent = nodeData.fontSize + 'px';
                        textEl.style.height = 'auto';
                        textEl.style.height = textEl.scrollHeight + 'px';
                        this.saveState();
                        this.saveToLocal();
                    }
                });
                
                increaseBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (nodeData.fontSize < 32) {
                        nodeData.fontSize += 2;
                        textEl.style.fontSize = nodeData.fontSize + 'px';
                        fontSizeDisplay.textContent = nodeData.fontSize + 'px';
                        textEl.style.height = 'auto';
                        textEl.style.height = textEl.scrollHeight + 'px';
                        this.saveState();
                        this.saveToLocal();
                    }
                });
                
                fontSizeControls.appendChild(decreaseBtn);
                fontSizeControls.appendChild(fontSizeDisplay);
                fontSizeControls.appendChild(increaseBtn);
                nodeEl.appendChild(fontSizeControls);
                
                // Color palette
                const colorPalette = document.createElement('div');
                colorPalette.className = 'color-palette';
                
                const colors = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                    'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
                    '#ffffff',
                    '#f3f4f6'
                ];
                
                colors.forEach(color => {
                    const colorBtn = document.createElement('div');
                    colorBtn.className = 'color-btn';
                    colorBtn.style.background = color;
                    if (color === '#ffffff' || color === '#f3f4f6') {
                        colorBtn.style.border = '1px solid #d1d5db';
                    }
                    colorBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        nodeData.customColor = color;
                        nodeEl.style.background = color;
                        if (color === '#ffffff' || color === '#f3f4f6') {
                            nodeEl.style.color = '#374151';
                        } else {
                            nodeEl.style.color = 'white';
                        }
                        this.saveState();
                        this.saveToLocal();
                    });
                    colorPalette.appendChild(colorBtn);
                });
                
                nodeEl.appendChild(colorPalette);
                
                // Delete button
                if (nodeData.level !== 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.innerHTML = '‚úï';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.deleteNode(nodeData.id);
                    });
                    nodeEl.appendChild(deleteBtn);
                }
                
                // Simple resize handle
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                resizeHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    this.resizingNode = nodeData;
                    this.resizeStart = {
                        x: e.clientX,
                        y: e.clientY,
                        width: nodeEl.offsetWidth,
                        height: nodeEl.offsetHeight
                    };
                });
                nodeEl.appendChild(resizeHandle);
                
                // Drag functionality
                nodeEl.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('connection-point') || 
                        e.target.classList.contains('delete-btn') ||
                        e.target.classList.contains('resize-handle') ||
                        e.target.classList.contains('color-btn') ||
                        e.target.classList.contains('font-size-btn')) return;
                    
                    if (!this.isDraggingConnection) {
                        // Check if clicking on already selected node with multiple selection
                        if (this.selectedNodes.has(nodeData.id) && this.selectedNodes.size > 1) {
                            // Start dragging all selected nodes
                            this.draggedNodes = Array.from(this.selectedNodes).map(id => {
                                const node = this.nodes.get(id);
                                return {
                                    node: node,
                                    offset: {
                                        x: e.clientX - node.x - this.viewOffset.x,
                                        y: e.clientY - node.y - this.viewOffset.y
                                    }
                                };
                            });
                        } else {
                            // Single node drag
                            if (e.ctrlKey || e.metaKey) {
                                // Add to selection
                                this.toggleNodeSelection(nodeData.id);
                            } else {
                                // Clear selection and select only this node
                                this.clearSelection();
                                this.selectNode(nodeData.id);
                            }
                            
                            this.draggedNode = nodeData;
                            this.dragOffset = {
                                x: e.clientX - nodeData.x - this.viewOffset.x,
                                y: e.clientY - nodeData.y - this.viewOffset.y
                            };
                        }
                    }
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.resizingNode) {
                        const nodeEl = document.getElementById(this.resizingNode.id);
                        if (nodeEl) {
                            const dx = e.clientX - this.resizeStart.x;
                            const dy = e.clientY - this.resizeStart.y;
                            const newWidth = Math.max(100, this.resizeStart.width + dx);
                            const newHeight = Math.max(40, this.resizeStart.height + dy);
                            
                            nodeEl.style.width = newWidth + 'px';
                            nodeEl.style.height = newHeight + 'px';
                            
                            this.resizingNode.width = newWidth;
                            this.resizingNode.height = newHeight;
                            
                            this.updateConnections();
                        }
                    }
                    
                    // Multi-node drag
                    if (this.draggedNodes.length > 0 && !this.isDraggingConnection) {
                        this.draggedNodes.forEach(item => {
                            item.node.x = e.clientX - item.offset.x - this.viewOffset.x;
                            item.node.y = e.clientY - item.offset.y - this.viewOffset.y;
                            const nodeEl = document.getElementById(item.node.id);
                            if (nodeEl) {
                                nodeEl.style.left = item.node.x + 'px';
                                nodeEl.style.top = item.node.y + 'px';
                            }
                        });
                        this.updateConnections();
                    }
                    // Single node drag
                    else if (this.draggedNode && !this.isDraggingConnection) {
                        this.draggedNode.x = e.clientX - this.dragOffset.x - this.viewOffset.x;
                        this.draggedNode.y = e.clientY - this.dragOffset.y - this.viewOffset.y;
                        const nodeEl = document.getElementById(this.draggedNode.id);
                        if (nodeEl) {
                            nodeEl.style.left = this.draggedNode.x + 'px';
                            nodeEl.style.top = this.draggedNode.y + 'px';
                            this.updateConnections();
                        }
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    // Clean up resize state
                    if (this.resizingNode) {
                        this.resizingNode = null;
                        this.resizeStart = null;
                        this.saveState();
                        this.saveToLocal();
                    }
                    
                    // Clean up drag state
                    if (this.draggedNodes.length > 0) {
                        this.draggedNodes = [];
                        this.saveState();
                        this.saveToLocal();
                        this.updateMinimap();
                    }
                    
                    if (this.draggedNode && !this.isDraggingConnection) {
                        this.draggedNode = null;
                        this.saveState();
                        this.saveToLocal();
                        this.updateMinimap();
                    }
                });
                
                this.nodesContainer.appendChild(nodeEl);
            }
            
            startConnection(nodeId, position, event) {
                this.connectionStart = { nodeId, position };
                this.isDraggingConnection = true;
                
                // Create temp connection line
                const tempPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                tempPath.id = 'temp-connection';
                tempPath.setAttribute('fill', 'none');
                tempPath.setAttribute('stroke', '#8b5cf6');
                tempPath.setAttribute('stroke-width', '2');
                tempPath.setAttribute('stroke-dasharray', '8,4');
                tempPath.setAttribute('stroke-linecap', 'round');
                tempPath.style.pointerEvents = 'none';
                tempPath.style.opacity = '0.7';
                this.connectionsGroup.appendChild(tempPath);
                
                // Initial update
                this.updateTempConnection(event);
            }
            
            updateTempConnection(e) {
                const tempPath = document.getElementById('temp-connection');
                if (!tempPath || !this.connectionStart) return;
                
                const startNode = this.nodes.get(this.connectionStart.nodeId);
                if (!startNode) return;
                
                const startPoint = this.getConnectionPoint(startNode, this.connectionStart.position);
                const endX = e.clientX - this.viewOffset.x;
                const endY = e.clientY - this.viewOffset.y;
                
                // Create curved path
                const dx = endX - startPoint.x;
                const dy = endY - startPoint.y;
                const cx = startPoint.x + dx * 0.5;
                
                const d = `M ${startPoint.x} ${startPoint.y} Q ${cx} ${startPoint.y}, ${endX} ${endY}`;
                tempPath.setAttribute('d', d);
            }
            
            removeTempConnection() {
                const tempPath = document.getElementById('temp-connection');
                if (tempPath) {
                    tempPath.remove();
                }
            }
            
            completeConnection(targetNodeId, targetPosition) {
                if (!this.connectionStart) return;
                
                this.removeTempConnection();
                
                const connectionId = `${this.connectionStart.nodeId}_${targetNodeId}`;
                const reverseConnectionId = `${targetNodeId}_${this.connectionStart.nodeId}`;
                
                // Check if connection already exists or connecting to self
                if (this.connectionStart.nodeId === targetNodeId) {
                    return;
                }
                
                if (this.connections.has(connectionId) || this.connections.has(reverseConnectionId)) {
                    return;
                }
                
                this.connections.set(connectionId, {
                    from: this.connectionStart.nodeId,
                    to: targetNodeId,
                    fromPos: this.connectionStart.position,
                    toPos: targetPosition
                });
                
                this.renderConnection(connectionId);
                this.saveState();
                this.saveToLocal();
                this.updateMinimap();
                this.updateStats();
            }
            
            renderConnection(connectionId) {
                const connection = this.connections.get(connectionId);
                if (!connection) return;
                
                const fromNode = this.nodes.get(connection.from);
                const toNode = this.nodes.get(connection.to);
                if (!fromNode || !toNode) return;
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.id = `connection_${connectionId}`;
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke', '#6b7280');
                path.setAttribute('stroke-width', '2');
                path.style.pointerEvents = 'stroke';
                path.style.cursor = 'pointer';
                
                // Add hover effect
                path.addEventListener('mouseenter', () => {
                    path.setAttribute('stroke', '#ef4444');
                    path.setAttribute('stroke-width', '3');
                });
                
                path.addEventListener('mouseleave', () => {
                    path.setAttribute('stroke', '#6b7280');
                    path.setAttribute('stroke-width', '2');
                });
                
                // Add click to delete
                path.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm('Ïù¥ Ïó∞Í≤∞ÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                        this.deleteConnection(connectionId);
                    }
                });
                
                this.updateConnectionPath(path, fromNode, toNode, connection);
                this.connectionsGroup.appendChild(path);
            }
            
            updateConnectionPath(path, fromNode, toNode, connection) {
                const fromPos = connection?.fromPos || 'right';
                const toPos = connection?.toPos || 'left';
                
                const fromPoint = this.getConnectionPoint(fromNode, fromPos);
                const toPoint = this.getConnectionPoint(toNode, toPos);
                
                // Create curved path
                const dx = toPoint.x - fromPoint.x;
                const dy = toPoint.y - fromPoint.y;
                
                // Control points for bezier curve
                let cx1, cy1, cx2, cy2;
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal connection
                    cx1 = fromPoint.x + dx * 0.5;
                    cy1 = fromPoint.y;
                    cx2 = fromPoint.x + dx * 0.5;
                    cy2 = toPoint.y;
                } else {
                    // Vertical connection
                    cx1 = fromPoint.x;
                    cy1 = fromPoint.y + dy * 0.5;
                    cx2 = toPoint.x;
                    cy2 = fromPoint.y + dy * 0.5;
                }
                
                const d = `M ${fromPoint.x} ${fromPoint.y} C ${cx1} ${cy1}, ${cx2} ${cy2}, ${toPoint.x} ${toPoint.y}`;
                path.setAttribute('d', d);
            }
            
            updateConnections() {
                this.connections.forEach((connection, id) => {
                    const path = document.getElementById(`connection_${id}`);
                    if (path) {
                        const fromNode = this.nodes.get(connection.from);
                        const toNode = this.nodes.get(connection.to);
                        if (fromNode && toNode) {
                            this.updateConnectionPath(path, fromNode, toNode, connection);
                        }
                    }
                });
            }
            
            deleteConnection(connectionId) {
                const path = document.getElementById(`connection_${connectionId}`);
                if (path) {
                    path.remove();
                }
                this.connections.delete(connectionId);
                this.saveToLocal();
                this.updateMinimap();
            }
            
            getConnectionPoint(node, position) {
                const nodeEl = document.getElementById(node.id);
                if (!nodeEl) return { x: node.x + 60, y: node.y + 25 };
                
                const rect = nodeEl.getBoundingClientRect();
                const width = rect.width / this.zoom;
                const height = rect.height / this.zoom;
                
                switch(position) {
                    case 'top':
                        return { x: node.x + width / 2, y: node.y };
                    case 'right':
                        return { x: node.x + width, y: node.y + height / 2 };
                    case 'bottom':
                        return { x: node.x + width / 2, y: node.y + height };
                    case 'left':
                        return { x: node.x, y: node.y + height / 2 };
                    default:
                        return { x: node.x + width / 2, y: node.y + height / 2 };
                }
            }
            
            selectNode(nodeId) {
                // Clear multi-selection
                this.clearSelection();
                
                // Add selection to current node
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('selected');
                    this.selectedNode = nodeId;
                    this.selectedNodes.add(nodeId);
                }
            }
            
            deleteNode(nodeId) {
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return; // Don't delete root
                
                // Remove node element
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) nodeEl.remove();
                
                // Remove connections
                const connectionsToRemove = [];
                this.connections.forEach((connection, id) => {
                    if (connection.from === nodeId || connection.to === nodeId) {
                        connectionsToRemove.push(id);
                        const pathEl = document.getElementById(`connection_${id}`);
                        if (pathEl) pathEl.remove();
                    }
                });
                
                connectionsToRemove.forEach(id => this.connections.delete(id));
                
                // Remove node
                this.nodes.delete(nodeId);
                this.selectedNode = null;
                this.saveToLocal();
                this.updateMinimap();
                this.updateStats();
            }
            
            addNode(parentId = null) {
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                    x: 2500 + Math.random() * 200 - 100,
                    y: 2500 + Math.random() * 200 - 100,
                    level: parentId ? (this.nodes.get(parentId)?.level || 0) + 1 : 1,
                    color: null,
                    fontSize: 14
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                
                // Auto connect to parent if provided
                if (parentId && this.nodes.has(parentId)) {
                    const connectionId = `${parentId}_${newNode.id}`;
                    this.connections.set(connectionId, {
                        from: parentId,
                        to: newNode.id
                    });
                    this.renderConnection(connectionId);
                }
                
                this.selectNode(newNode.id);
                this.saveToLocal();
                this.updateMinimap();
                this.updateStats();
                
                // Focus on text input
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addChildNode(parentId) {
                if (!parentId) parentId = this.selectedNode;
                if (!parentId) return;
                
                const parent = this.nodes.get(parentId);
                if (!parent) return;
                
                // Calculate position for child
                const angle = Math.random() * Math.PI * 2;
                const distance = 150;
                
                const newNode = {
                    id: 'node_' + this.nodeIdCounter++,
                    text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                    x: parent.x + Math.cos(angle) * distance,
                    y: parent.y + Math.sin(angle) * distance,
                    level: parent.level + 1,
                    color: null,
                    fontSize: 14
                };
                
                this.nodes.set(newNode.id, newNode);
                this.renderNode(newNode);
                
                // Connect to parent
                const connectionId = `${parentId}_${newNode.id}`;
                this.connections.set(connectionId, {
                    from: parentId,
                    to: newNode.id
                });
                this.renderConnection(connectionId);
                
                this.selectNode(newNode.id);
                this.saveToLocal();
                this.updateMinimap();
                this.updateStats();
                
                // Focus on text input
                setTimeout(() => {
                    const nodeEl = document.getElementById(newNode.id);
                    const textInput = nodeEl.querySelector('.node-text');
                    textInput.focus();
                    textInput.select();
                }, 50);
            }
            
            addSiblingNode(nodeId) {
                if (!nodeId) nodeId = this.selectedNode;
                if (!nodeId) return;
                
                const node = this.nodes.get(nodeId);
                if (!node || node.level === 0) return;
                
                // Find parent connection
                let parentId = null;
                this.connections.forEach(connection => {
                    if (connection.to === nodeId) {
                        parentId = connection.from;
                    }
                });
                
                if (parentId) {
                    this.addChildNode(parentId);
                } else {
                    // If no parent, just add a node at the same level
                    const newNode = {
                        id: 'node_' + this.nodeIdCounter++,
                        text: 'ÏÉà ÏïÑÏù¥ÎîîÏñ¥',
                        x: node.x + 150,
                        y: node.y,
                        level: node.level,
                        color: null,
                        fontSize: 14
                    };
                    
                    this.nodes.set(newNode.id, newNode);
                    this.renderNode(newNode);
                    this.selectNode(newNode.id);
                    this.saveToLocal();
                    this.updateMinimap();
                }
            }
            
            centerView() {
                if (this.nodes.size === 0) return;
                
                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;
                
                this.nodes.forEach(node => {
                    minX = Math.min(minX, node.x);
                    minY = Math.min(minY, node.y);
                    maxX = Math.max(maxX, node.x);
                    maxY = Math.max(maxY, node.y);
                });
                
                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;
                
                this.viewOffset.x = window.innerWidth / 2 - centerX;
                this.viewOffset.y = window.innerHeight / 2 - centerY;
                
                this.updateView();
            }
            
            // Auto-layout feature - arrange nodes beautifully
            autoLayout() {
                if (this.nodes.size === 0) return;
                
                this.saveState(); // For undo
                
                // Build tree structure
                const root = Array.from(this.nodes.values()).find(n => n.level === 0);
                if (!root) return;
                
                // Create adjacency list
                const children = new Map();
                const parents = new Map();
                this.nodes.forEach(node => {
                    children.set(node.id, []);
                });
                
                this.connections.forEach(conn => {
                    const childList = children.get(conn.from) || [];
                    childList.push(conn.to);
                    children.set(conn.from, childList);
                    parents.set(conn.to, conn.from);
                });
                
                // Layout parameters
                const HORIZONTAL_SPACING = 250;
                const VERTICAL_SPACING = 120;
                const SIBLING_SPACING = 100;
                
                // Calculate subtree width
                const getSubtreeWidth = (nodeId) => {
                    const nodeChildren = children.get(nodeId) || [];
                    if (nodeChildren.length === 0) return 150; // Node width
                    
                    let totalWidth = 0;
                    nodeChildren.forEach(childId => {
                        totalWidth += getSubtreeWidth(childId);
                    });
                    
                    // Add spacing between children
                    totalWidth += (nodeChildren.length - 1) * SIBLING_SPACING;
                    
                    return Math.max(150, totalWidth);
                };
                
                // Radial layout for first level, hierarchical for rest
                const layoutNode = (nodeId, x, y, level = 0) => {
                    const node = this.nodes.get(nodeId);
                    if (!node) return;
                    
                    // Update node position with animation
                    node.x = x;
                    node.y = y;
                    
                    const nodeEl = document.getElementById(nodeId);
                    if (nodeEl) {
                        nodeEl.style.transition = 'left 0.6s cubic-bezier(0.4, 0, 0.2, 1), top 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                        nodeEl.style.left = x + 'px';
                        nodeEl.style.top = y + 'px';
                        
                        setTimeout(() => {
                            nodeEl.style.transition = '';
                        }, 600);
                    }
                    
                    const nodeChildren = children.get(nodeId) || [];
                    if (nodeChildren.length === 0) return;
                    
                    if (level === 0) {
                        // Root node - arrange children in a semi-circle
                        const angleRange = Math.PI; // 180 degrees
                        const startAngle = -angleRange / 2;
                        const angleStep = nodeChildren.length > 1 ? angleRange / (nodeChildren.length - 1) : 0;
                        const radius = Math.max(200, nodeChildren.length * 40);
                        
                        nodeChildren.forEach((childId, index) => {
                            const angle = startAngle + index * angleStep;
                            const childX = x + Math.cos(angle) * radius;
                            const childY = y + Math.sin(angle) * radius;
                            layoutNode(childId, childX, childY, level + 1);
                        });
                    } else {
                        // Non-root nodes - hierarchical layout
                        const subtreeWidth = getSubtreeWidth(nodeId);
                        let currentX = x - subtreeWidth / 2;
                        
                        nodeChildren.forEach((childId, index) => {
                            const childWidth = getSubtreeWidth(childId);
                            const childX = currentX + childWidth / 2;
                            const childY = y + VERTICAL_SPACING;
                            
                            layoutNode(childId, childX, childY, level + 1);
                            
                            currentX += childWidth + SIBLING_SPACING;
                        });
                    }
                };
                
                // Start layout from root at center
                const centerX = 2500;
                const centerY = 2300;
                layoutNode(root.id, centerX, centerY, 0);
                
                // Update connections after animation
                setTimeout(() => {
                    this.updateConnections();
                    this.saveToLocal();
                    this.updateMinimap();
                    this.updateStats();
                    this.centerView();
                }, 650);
                
                this.showToast('‚ú® ÏûêÎèô Ï†ïÎ†¨ ÏôÑÎ£å!');
            }
            
            updateView() {
                const transform = `translate(${this.viewOffset.x}px, ${this.viewOffset.y}px) scale(${this.zoom})`;
                this.canvas.style.transform = transform;
                this.nodesContainer.style.transform = transform;
                // Make sure both are synchronized
                this.canvas.style.transformOrigin = '0 0';
                this.nodesContainer.style.transformOrigin = '0 0';
            }
            
            zoomIn() {
                this.zoom = Math.min(2, this.zoom * 1.2);
                this.updateView();
            }
            
            zoomOut() {
                this.zoom = Math.max(0.5, this.zoom / 1.2);
                this.updateView();
            }
            
            resetZoom() {
                this.zoom = 1;
                this.updateView();
            }
            
            updateMinimap() {
                const canvas = this.minimapCanvas;
                const ctx = this.minimapCtx;
                const scale = 0.02;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw connections
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                this.connections.forEach(connection => {
                    const fromNode = this.nodes.get(connection.from);
                    const toNode = this.nodes.get(connection.to);
                    if (fromNode && toNode) {
                        ctx.beginPath();
                        ctx.moveTo(fromNode.x * scale, fromNode.y * scale);
                        ctx.lineTo(toNode.x * scale, toNode.y * scale);
                        ctx.stroke();
                    }
                });
                
                // Draw nodes
                this.nodes.forEach(node => {
                    ctx.fillStyle = node.level === 0 ? '#3b82f6' : '#6b7280';
                    ctx.fillRect(
                        node.x * scale - 2,
                        node.y * scale - 2,
                        4,
                        4
                    );
                });
            }
            
            saveToLocal() {
                this.saveBoards();
            }
            
            loadFromLocal() {
                // This method is now handled by loadBoards and switchBoard
                // Keeping for backward compatibility - migrate old data if exists
                const oldData = localStorage.getItem('mindMapData');
                if (oldData && this.boards.size === 0) {
                    try {
                        const data = JSON.parse(oldData);
                        
                        // Create a default board with old data
                        const boardId = 'board_0';
                        const nodesMap = new Map();
                        const connectionsMap = new Map();
                        
                        data.nodes.forEach(node => {
                            nodesMap.set(node.id, node);
                        });
                        
                        data.connections.forEach(conn => {
                            connectionsMap.set(conn.id, {
                                from: conn.from,
                                to: conn.to,
                                fromPos: conn.fromPos,
                                toPos: conn.toPos
                            });
                        });
                        
                        this.boards.set(boardId, {
                            id: boardId,
                            name: 'Í∏∞Ï°¥ ÎßàÏù∏ÎìúÎßµ',
                            nodes: nodesMap,
                            connections: connectionsMap,
                            nodeIdCounter: data.nodeIdCounter || 0,
                            createdAt: new Date().toISOString()
                        });
                        
                        this.boardIdCounter = 1;
                        
                        // Remove old data format
                        localStorage.removeItem('mindMapData');
                        
                        // Save in new format
                        this.saveBoards();
                    } catch (e) {
                        console.error('Failed to migrate old data:', e);
                    }
                }
            }
            
            exportData() {
                const data = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mindmap-${new Date().toISOString().slice(0, 10)}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            importData() {
                const input = document.getElementById('file-input');
                input.click();
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = JSON.parse(e.target.result);
                                this.clearAll(false);
                                
                                // Load nodes
                                data.nodes.forEach(node => {
                                    this.nodes.set(node.id, node);
                                    this.renderNode(node);
                                });
                                
                                // Load connections
                                data.connections.forEach(conn => {
                                    this.connections.set(conn.id, {
                                        from: conn.from,
                                        to: conn.to
                                    });
                                    this.renderConnection(conn.id);
                                });
                                
                                this.nodeIdCounter = data.nodeIdCounter || 0;
                                this.saveToLocal();
                                this.updateMinimap();
                                this.centerView();
                            } catch (err) {
                                alert('ÌååÏùºÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
                            }
                        };
                        reader.readAsText(file);
                    }
                };
            }
            
            clearAll(confirm = true) {
                if (confirm && !window.confirm('Î™®Îì† ÎÇ¥Ïö©Ïù¥ ÏÇ≠Ï†úÎê©ÎãàÎã§. Í≥ÑÏÜçÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                    return;
                }
                
                // Clear DOM
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                
                // Clear data
                this.nodes.clear();
                this.connections.clear();
                this.selectedNode = null;
                this.nodeIdCounter = 0;
                
                // Create new root
                this.createRootNode();
                this.saveToLocal();
                this.updateMinimap();
                this.centerView();
            }
            // Undo/Redo functionality
            saveState() {
                const state = {
                    nodes: Array.from(this.nodes.values()),
                    connections: Array.from(this.connections.entries()).map(([id, conn]) => ({
                        id,
                        ...conn
                    })),
                    nodeIdCounter: this.nodeIdCounter
                };
                
                this.history = this.history.slice(0, this.historyIndex + 1);
                this.history.push(JSON.stringify(state));
                
                if (this.history.length > this.maxHistory) {
                    this.history.shift();
                } else {
                    this.historyIndex++;
                }
            }
            
            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.loadState(this.history[this.historyIndex]);
                    this.showToast('Ïã§Ìñâ Ï∑®ÏÜå');
                }
            }
            
            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.loadState(this.history[this.historyIndex]);
                    this.showToast('Îã§Ïãú Ïã§Ìñâ');
                }
            }
            
            loadState(stateStr) {
                const state = JSON.parse(stateStr);
                
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                this.nodes.clear();
                this.connections.clear();
                
                state.nodes.forEach(node => {
                    this.nodes.set(node.id, node);
                    this.renderNode(node);
                });
                
                state.connections.forEach(conn => {
                    this.connections.set(conn.id, {
                        from: conn.from,
                        to: conn.to,
                        fromPos: conn.fromPos || 'right',
                        toPos: conn.toPos || 'left'
                    });
                    this.renderConnection(conn.id);
                });
                
                this.nodeIdCounter = state.nodeIdCounter;
            }
            
            // Copy/Paste
            copy() {
                if (this.selectedNode) {
                    const node = this.nodes.get(this.selectedNode);
                    if (node) {
                        this.copiedNode = JSON.parse(JSON.stringify(node));
                        this.showToast('Î≥µÏÇ¨Îê®');
                    }
                }
            }
            
            paste() {
                if (this.copiedNode) {
                    const newNode = {
                        ...this.copiedNode,
                        id: 'node_' + this.nodeIdCounter++,
                        x: this.copiedNode.x + 50,
                        y: this.copiedNode.y + 50
                    };
                    
                    this.nodes.set(newNode.id, newNode);
                    this.renderNode(newNode);
                    this.selectNode(newNode.id);
                    this.saveState();
                    this.saveToLocal();
                    this.showToast('Î∂ôÏó¨ÎÑ£Í∏∞ ÏôÑÎ£å');
                }
            }
            
            // Multi-select functions
            startSelection(e) {
                this.isSelecting = true;
                this.selectionStart = {
                    x: e.clientX,
                    y: e.clientY
                };
                
                // Create selection box
                this.selectionBox = document.createElement('div');
                this.selectionBox.className = 'selection-box';
                this.container.appendChild(this.selectionBox);
            }
            
            updateSelection(e) {
                if (!this.selectionBox) return;
                
                const x1 = Math.min(this.selectionStart.x, e.clientX);
                const y1 = Math.min(this.selectionStart.y, e.clientY);
                const x2 = Math.max(this.selectionStart.x, e.clientX);
                const y2 = Math.max(this.selectionStart.y, e.clientY);
                
                this.selectionBox.style.left = x1 + 'px';
                this.selectionBox.style.top = y1 + 'px';
                this.selectionBox.style.width = (x2 - x1) + 'px';
                this.selectionBox.style.height = (y2 - y1) + 'px';
                
                // Check which nodes are in selection
                this.nodes.forEach((node, id) => {
                    const nodeEl = document.getElementById(id);
                    if (nodeEl) {
                        const rect = nodeEl.getBoundingClientRect();
                        const nodeX = rect.left + rect.width / 2;
                        const nodeY = rect.top + rect.height / 2;
                        
                        if (nodeX >= x1 && nodeX <= x2 && nodeY >= y1 && nodeY <= y2) {
                            this.addToSelection(id);
                        } else if (!e.ctrlKey && !e.metaKey) {
                            this.removeFromSelection(id);
                        }
                    }
                });
            }
            
            endSelection() {
                this.isSelecting = false;
                if (this.selectionBox) {
                    this.selectionBox.remove();
                    this.selectionBox = null;
                }
            }
            
            addToSelection(nodeId) {
                this.selectedNodes.add(nodeId);
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.add('multi-selected');
                }
            }
            
            removeFromSelection(nodeId) {
                this.selectedNodes.delete(nodeId);
                const nodeEl = document.getElementById(nodeId);
                if (nodeEl) {
                    nodeEl.classList.remove('multi-selected');
                }
            }
            
            clearSelection() {
                this.selectedNodes.forEach(id => {
                    const nodeEl = document.getElementById(id);
                    if (nodeEl) {
                        nodeEl.classList.remove('multi-selected');
                        nodeEl.classList.remove('selected');
                    }
                });
                this.selectedNodes.clear();
                this.selectedNode = null;
            }
            
            toggleNodeSelection(nodeId) {
                if (this.selectedNodes.has(nodeId)) {
                    this.removeFromSelection(nodeId);
                } else {
                    this.addToSelection(nodeId);
                }
            }
            
            // Toast notification
            showToast(message) {
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    bottom: 30px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 1000;
                    animation: fadeIn 0.3s;
                `;
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => {
                    toast.style.animation = 'fadeOut 0.3s';
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            }
            
            // Settings modal
            openSettings() {
                // Create settings modal
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white rounded-2xl p-6 max-w-md w-full mx-4">
                        <h2 class="text-2xl font-bold mb-4">‚öôÔ∏è ÏÑ§Ï†ï</h2>
                        
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    üé® ÌÖåÎßà ÏÉâÏÉÅ
                                </label>
                                <select id="theme-color" class="w-full px-4 py-2 border rounded-lg">
                                    <option value="purple">Î≥¥ÎùºÏÉâ (Í∏∞Î≥∏)</option>
                                    <option value="blue">ÌååÎûÄÏÉâ</option>
                                    <option value="green">Ï¥àÎ°ùÏÉâ</option>
                                    <option value="red">Îπ®Í∞ÑÏÉâ</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    üìè Í∏∞Î≥∏ ÎÖ∏Îìú ÌÅ¨Í∏∞
                                </label>
                                <input type="range" id="default-node-size" min="100" max="200" value="120" 
                                       class="w-full">
                                <span id="size-display" class="text-sm text-gray-500">120px</span>
                            </div>
                            
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">
                                    üîó Ïó∞Í≤∞ÏÑ† Ïä§ÌÉÄÏùº
                                </label>
                                <select id="line-style" class="w-full px-4 py-2 border rounded-lg">
                                    <option value="curved">Í≥°ÏÑ†</option>
                                    <option value="straight">ÏßÅÏÑ†</option>
                                    <option value="elbow">Í∫æÏù∏ÏÑ†</option>
                                </select>
                            </div>
                            
                            <div>
                                <label class="flex items-center gap-2">
                                    <input type="checkbox" id="auto-save" checked class="rounded">
                                    <span class="text-sm font-medium text-gray-700">ÏûêÎèô Ï†ÄÏû•</span>
                                </label>
                            </div>
                        </div>
                        
                        <div class="flex gap-2 mt-6">
                            <button onclick="this.closest('.fixed').remove()" 
                                    class="flex-1 px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">
                                Ï∑®ÏÜå
                            </button>
                            <button onclick="mindMap.saveSettings(); this.closest('.fixed').remove()" 
                                    class="flex-1 px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                                Ï†ÄÏû•
                            </button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Handle click outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
                
                // Update size display
                const sizeInput = document.getElementById('default-node-size');
                const sizeDisplay = document.getElementById('size-display');
                sizeInput.addEventListener('input', () => {
                    sizeDisplay.textContent = sizeInput.value + 'px';
                });
            }
            
            saveSettings() {
                // Save settings to localStorage
                const settings = {
                    themeColor: document.getElementById('theme-color').value,
                    defaultNodeSize: document.getElementById('default-node-size').value,
                    lineStyle: document.getElementById('line-style').value,
                    autoSave: document.getElementById('auto-save').checked
                };
                
                localStorage.setItem('mindMapSettings', JSON.stringify(settings));
                this.showToast('ÏÑ§Ï†ïÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§');
            }
            
            // Show help modal
            showHelp() {
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white rounded-2xl p-6 max-w-2xl w-full mx-4 max-h-[80vh] overflow-y-auto">
                        <h2 class="text-2xl font-bold mb-4">üìñ ÏÇ¨Ïö© Í∞ÄÏù¥Îìú</h2>
                        
                        <div class="space-y-4">
                            <div class="bg-blue-50 p-4 rounded-lg">
                                <h3 class="font-bold text-blue-900 mb-2">üéØ Í∞ÑÌé∏Ìïú ÏÉÅÌò∏ÏûëÏö©</h3>
                                <ul class="space-y-1 text-sm text-blue-800">
                                    <li>‚Ä¢ <b>ÎÖ∏Îìú Ïù¥Îèô</b>: ÎÖ∏ÎìúÎ•º ÎìúÎûòÍ∑∏ÌïòÏó¨ ÏûêÏú†Î°≠Í≤å Ïù¥Îèô</li>
                                    <li>‚Ä¢ <b>ÌÅ¨Í∏∞ Ï°∞Ï†à</b>: Ïö∞ÌïòÎã® Î™®ÏÑúÎ¶¨ ÎìúÎûòÍ∑∏Î°ú ÌÅ¨Í∏∞ Ï°∞Ï†à</li>
                                    <li>‚Ä¢ <b>Ïó∞Í≤∞ÏÑ† ÏÉùÏÑ±</b>: Ïó∞Í≤∞Ï†êÏùÑ ÎìúÎûòÍ∑∏ÌïòÏó¨ ÎÖ∏Îìú Ïó∞Í≤∞</li>
                                    <li>‚Ä¢ <b>Îπ†Î•∏ Î∞òÏùë</b>: ÏµúÏ†ÅÌôîÎêú ÏÑ±Îä•ÏúºÎ°ú Î∂ÄÎìúÎü¨Ïö¥ Ï°∞Ïûë</li>
                                </ul>
                            </div>
                            
                            <div class="bg-purple-50 p-4 rounded-lg">
                                <h3 class="font-bold text-purple-900 mb-2">‚å®Ô∏è ÌÇ§Î≥¥Îìú Îã®Ï∂ïÌÇ§</h3>
                                <div class="grid grid-cols-2 gap-2 text-sm text-purple-800">
                                    <div><kbd class="px-2 py-1 bg-white rounded">Enter</kbd> ÏûêÏãù ÎÖ∏Îìú Ï∂îÍ∞Ä</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Tab</kbd> ÌòïÏ†ú ÎÖ∏Îìú Ï∂îÍ∞Ä</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Delete</kbd> ÏÑ†ÌÉù ÎÖ∏Îìú ÏÇ≠Ï†ú</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Ctrl+Z</kbd> Ïã§Ìñâ Ï∑®ÏÜå</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Ctrl+Y</kbd> Îã§Ïãú Ïã§Ìñâ</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Ctrl+C</kbd> Î≥µÏÇ¨</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Ctrl+V</kbd> Î∂ôÏó¨ÎÑ£Í∏∞</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Ctrl+S</kbd> Ï†ÄÏû•</div>
                                    <div><kbd class="px-2 py-1 bg-white rounded">Shift+ÎìúÎûòÍ∑∏</kbd> Îã§Ï§ë ÏÑ†ÌÉù</div>
                                </div>
                            </div>
                            
                            <div class="bg-green-50 p-4 rounded-lg">
                                <h3 class="font-bold text-green-900 mb-2">üñ±Ô∏è ÎßàÏö∞Ïä§ Ï°∞Ïûë</h3>
                                <ul class="space-y-1 text-sm text-green-800">
                                    <li>‚Ä¢ <b>ÎÖ∏Îìú ÎìúÎûòÍ∑∏</b>: Ïù¥Îèô Î™®ÎìúÏóêÏÑú ÎÖ∏Îìú Ïù¥Îèô</li>
                                    <li>‚Ä¢ <b>Ïó∞Í≤∞Ï†ê ÎìúÎûòÍ∑∏</b>: ÎÖ∏Îìú Í∞Ñ Ïó∞Í≤∞ÏÑ† ÏÉùÏÑ±</li>
                                    <li>‚Ä¢ <b>Îπà Í≥µÍ∞Ñ ÎìúÎûòÍ∑∏</b>: Ï∫îÎ≤ÑÏä§ Ïù¥Îèô</li>
                                    <li>‚Ä¢ <b>Shift+ÎìúÎûòÍ∑∏</b>: ÏòÅÏó≠ ÏÑ†ÌÉùÏúºÎ°ú Îã§Ï§ë ÏÑ†ÌÉù</li>
                                    <li>‚Ä¢ <b>Ï§å Î≤ÑÌäº</b>: Ïö∞Ï∏° ÌïòÎã® +/- Î≤ÑÌäºÏúºÎ°ú ÌôïÎåÄ/Ï∂ïÏÜå</li>
                                </ul>
                            </div>
                            
                            <div class="bg-yellow-50 p-4 rounded-lg">
                                <h3 class="font-bold text-yellow-900 mb-2">üí° ÌåÅ</h3>
                                <ul class="space-y-1 text-sm text-yellow-800">
                                    <li>‚Ä¢ ÎÖ∏Îìú ÏúÑ Ìò∏Î≤Ñ Ïãú ÏÉâÏÉÅ ÌåîÎ†àÌä∏ÏôÄ Í∏ÄÏûê ÌÅ¨Í∏∞ Ï°∞Ï†à Î≤ÑÌäº ÌëúÏãú</li>
                                    <li>‚Ä¢ Ïó∞Í≤∞ÏÑ† ÌÅ¥Î¶≠ÏúºÎ°ú ÏÇ≠Ï†ú Í∞ÄÎä•</li>
                                    <li>‚Ä¢ Shift+EnterÎ°ú ÎÖ∏Îìú ÎÇ¥ Ï§ÑÎ∞îÍøà</li>
                                    <li>‚Ä¢ Ïó¨Îü¨ ÎÖ∏Îìú ÏÑ†ÌÉù ÌõÑ Ìï®Íªò Ïù¥Îèô Í∞ÄÎä•</li>
                                    <li>‚Ä¢ ÌÅ¨Í∏∞Ï°∞Ï†à Ïãú ÏµúÏÜå ÌÅ¨Í∏∞ Ï†úÌïúÏúºÎ°ú ÏïàÏ†ïÏÑ± Î≥¥Ïû•</li>
                                </ul>
                            </div>
                        </div>
                        
                        <button onclick="this.closest('.fixed').remove()" 
                                class="mt-6 w-full px-4 py-2 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-lg hover:from-purple-700 hover:to-pink-700">
                            Îã´Í∏∞
                        </button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // Close on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            // Board management methods
            createNewBoard(name = null) {
                // Get name from input field if not provided
                if (!name) {
                    const input = document.getElementById('new-board-name');
                    name = input ? input.value.trim() : '';
                    if (input) input.value = '';
                }
                
                const boardName = name || prompt('ÏÉà Î≥¥Îìú Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî:', 'ÏÉà ÎßàÏù∏ÎìúÎßµ');
                if (!boardName || !boardName.trim()) return;
                
                const boardId = 'board_' + this.boardIdCounter++;
                const boardData = {
                    id: boardId,
                    name: boardName,
                    nodes: new Map(),
                    connections: new Map(),
                    nodeIdCounter: 0,
                    createdAt: new Date().toISOString()
                };
                
                this.boards.set(boardId, boardData);
                this.switchBoard(boardId);
                this.saveBoards();
                this.updateBoardsList();
                this.showToast(`Î≥¥Îìú "${boardName}" ÏÉùÏÑ±Îê®`);
            }
            
            switchBoard(boardId) {
                // Save current board data if exists
                if (this.currentBoardId) {
                    const currentBoard = this.boards.get(this.currentBoardId);
                    if (currentBoard) {
                        currentBoard.nodes = new Map(this.nodes);
                        currentBoard.connections = new Map(this.connections);
                        currentBoard.nodeIdCounter = this.nodeIdCounter;
                    }
                }
                
                // Clear current display
                this.nodesContainer.innerHTML = '';
                this.connectionsGroup.innerHTML = '';
                this.nodes.clear();
                this.connections.clear();
                this.selectedNode = null;
                this.selectedNodes.clear();
                
                // Load new board
                const board = this.boards.get(boardId);
                if (board) {
                    this.currentBoardId = boardId;
                    this.nodes = new Map(board.nodes);
                    this.connections = new Map(board.connections);
                    this.nodeIdCounter = board.nodeIdCounter;
                    
                    // Render all nodes and connections
                    this.nodes.forEach(node => this.renderNode(node));
                    this.connections.forEach((conn, id) => this.renderConnection(id));
                    
                    // If empty board, create root node
                    if (this.nodes.size === 0) {
                        this.createRootNode();
                    }
                    
                    // Update view
                    setTimeout(() => this.centerView(), 100);
                    this.updateMinimap();
                    this.updateBoardsList();
                }
            }
            
            deleteBoard(boardId) {
                if (this.boards.size <= 1) {
                    this.showToast('ÏµúÏÜå ÌïòÎÇòÏùò Î≥¥ÎìúÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§');
                    return;
                }
                
                const board = this.boards.get(boardId);
                if (confirm(`"${board.name}" Î≥¥ÎìúÎ•º ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?`)) {
                    this.boards.delete(boardId);
                    
                    if (this.currentBoardId === boardId) {
                        const firstBoard = Array.from(this.boards.keys())[0];
                        this.switchBoard(firstBoard);
                    }
                    
                    this.saveBoards();
                    this.updateBoardsList();
                    this.showToast('Î≥¥ÎìúÍ∞Ä ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§');
                }
            }
            
            updateBoardsList() {
                const boardsList = document.getElementById('boards-list');
                boardsList.innerHTML = '';
                
                // Update statistics
                this.updateStats();
                
                this.boards.forEach((board, boardId) => {
                    const boardItem = document.createElement('div');
                    const isActive = boardId === this.currentBoardId;
                    
                    boardItem.className = `flex items-center gap-3 px-4 py-3 rounded-2xl cursor-pointer transition-all duration-300 card-hover ${
                        isActive ? 'category-active text-white shadow-lg' : 'glassmorphism hover:shadow-md'
                    }`;
                    
                    const nodeCount = board.nodes instanceof Map ? board.nodes.size : (board.nodes ? board.nodes.length : 0);
                    
                    boardItem.innerHTML = `
                        <span class="text-lg w-6 text-center">üß†</span>
                        <div class="flex-1">
                            <div class="font-medium">${board.name}</div>
                            <div class="text-xs ${isActive ? 'text-white/80' : 'text-gray-500'}">
                                ${nodeCount}Í∞ú ÎÖ∏Îìú
                            </div>
                        </div>
                        <button 
                            onclick="event.stopPropagation(); mindMap.deleteBoard('${boardId}')"
                            class="${isActive ? 'text-white/80 hover:text-white' : 'text-gray-400 hover:text-red-600'}"
                            title="ÏÇ≠Ï†ú">
                            ‚úï
                        </button>
                    `;
                    
                    boardItem.addEventListener('click', () => {
                        this.switchBoard(boardId);
                    });
                    
                    boardsList.appendChild(boardItem);
                });
            }
            
            updateStats() {
                // Calculate statistics
                let totalNodes = 0;
                let totalConnections = 0;
                
                this.boards.forEach(board => {
                    if (board.nodes instanceof Map) {
                        totalNodes += board.nodes.size;
                    } else if (board.nodes) {
                        totalNodes += board.nodes.length;
                    }
                    
                    if (board.connections instanceof Map) {
                        totalConnections += board.connections.size;
                    } else if (board.connections) {
                        totalConnections += board.connections.length;
                    }
                });
                
                // Update current board stats
                const currentNodes = this.nodes.size;
                const currentConnections = this.connections.size;
                
                // Update display
                document.getElementById('total-nodes').textContent = currentNodes;
                document.getElementById('total-boards').textContent = this.boards.size;
                document.getElementById('connections-count').textContent = currentConnections;
                
                // Update progress bar (connections vs nodes ratio)
                const progress = currentNodes > 0 ? Math.min(100, Math.round((currentConnections / currentNodes) * 100)) : 0;
                const progressBar = document.getElementById('progress-bar');
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }
            }
            
            saveBoards() {
                // Save current board data
                if (this.currentBoardId) {
                    const currentBoard = this.boards.get(this.currentBoardId);
                    if (currentBoard) {
                        currentBoard.nodes = Array.from(this.nodes.values());
                        currentBoard.connections = Array.from(this.connections.entries()).map(([id, conn]) => ({
                            id,
                            ...conn
                        }));
                        currentBoard.nodeIdCounter = this.nodeIdCounter;
                    }
                }
                
                // Save all boards
                const boardsData = Array.from(this.boards.entries()).map(([id, board]) => ({
                    id,
                    name: board.name,
                    nodes: board.nodes instanceof Map ? Array.from(board.nodes.values()) : board.nodes,
                    connections: board.connections instanceof Map ? 
                        Array.from(board.connections.entries()).map(([id, conn]) => ({id, ...conn})) : 
                        board.connections,
                    nodeIdCounter: board.nodeIdCounter,
                    createdAt: board.createdAt
                }));
                
                localStorage.setItem('mindMapBoards', JSON.stringify(boardsData));
                localStorage.setItem('currentBoardId', this.currentBoardId);
                localStorage.setItem('boardIdCounter', this.boardIdCounter.toString());
            }
            
            loadBoards() {
                const boardsData = localStorage.getItem('mindMapBoards');
                const currentBoardId = localStorage.getItem('currentBoardId');
                const boardIdCounter = localStorage.getItem('boardIdCounter');
                
                if (boardIdCounter) {
                    this.boardIdCounter = parseInt(boardIdCounter);
                }
                
                if (boardsData) {
                    try {
                        const boards = JSON.parse(boardsData);
                        boards.forEach(board => {
                            const nodesMap = new Map();
                            const connectionsMap = new Map();
                            
                            if (board.nodes) {
                                board.nodes.forEach(node => {
                                    nodesMap.set(node.id, node);
                                });
                            }
                            
                            if (board.connections) {
                                board.connections.forEach(conn => {
                                    connectionsMap.set(conn.id, {
                                        from: conn.from,
                                        to: conn.to,
                                        fromPos: conn.fromPos,
                                        toPos: conn.toPos
                                    });
                                });
                            }
                            
                            this.boards.set(board.id, {
                                id: board.id,
                                name: board.name,
                                nodes: nodesMap,
                                connections: connectionsMap,
                                nodeIdCounter: board.nodeIdCounter || 0,
                                createdAt: board.createdAt
                            });
                        });
                        
                        if (currentBoardId && this.boards.has(currentBoardId)) {
                            this.currentBoardId = currentBoardId;
                        }
                    } catch (e) {
                        console.error('Failed to load boards:', e);
                    }
                }
            }
        }
        
        // Add fade animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateX(-50%) translateY(10px); }
                to { opacity: 1; transform: translateX(-50%) translateY(0); }
            }
            @keyframes fadeOut {
                from { opacity: 1; transform: translateX(-50%) translateY(0); }
                to { opacity: 0; transform: translateX(-50%) translateY(10px); }
            }
        `;
        document.head.appendChild(style);
        
        // Authentication Component
        function AuthOverlay() {
            const overlay = document.createElement('div');
            overlay.className = 'auth-overlay';
            overlay.innerHTML = `
                <div class="auth-modal">
                    <div class="text-center mb-8">
                        <div class="w-20 h-20 rounded-full bg-gradient-to-br from-purple-500 to-pink-600 flex items-center justify-center mx-auto mb-4">
                            <span class="text-3xl">üß†</span>
                        </div>
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">MindFlow</h2>
                        <p class="text-gray-600">Î™®Îì† Í∏∞Í∏∞ÏóêÏÑú ÎèôÍ∏∞ÌôîÎêòÎäî Ïä§ÎßàÌä∏ ÎßàÏù∏ÎìúÎßµ</p>
                    </div>

                    <div class="space-y-4">
                        <button id="google-signin-btn" class="w-full px-6 py-3 bg-white border border-gray-300 rounded-xl hover:bg-gray-50 flex items-center justify-center gap-3 transition-all duration-200 shadow-sm hover:shadow-md">
                            <svg class="w-5 h-5" viewBox="0 0 24 24">
                                <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                            </svg>
                            <span>GoogleÎ°ú Í≥ÑÏÜçÌïòÍ∏∞</span>
                        </button>

                        <button id="local-storage-btn" class="w-full px-6 py-3 bg-gray-100 text-gray-700 rounded-xl hover:bg-gray-200 transition-all duration-200">
                            Î°úÏª¨ Ï†ÄÏû•ÏÜåÎ°ú Í≥ÑÏÜçÌïòÍ∏∞
                        </button>
                    </div>

                    <div id="auth-error" class="mt-4 p-3 bg-red-50 text-red-600 rounded-lg text-sm hidden">
                    </div>

                    <div class="mt-6 pt-6 border-t border-gray-200">
                        <p class="text-xs text-gray-500 text-center">
                            Î°úÍ∑∏Ïù∏ÌïòÎ©¥ Î™®Îì† Í∏∞Í∏∞ÏóêÏÑú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûêÎèôÏúºÎ°ú ÎèôÍ∏∞ÌôîÎê©ÎãàÎã§.
                            Î°úÏª¨ Ï†ÄÏû•ÏÜåÎ•º ÏÇ¨Ïö©ÌïòÎ©¥ ÌòÑÏû¨ Î∏åÎùºÏö∞Ï†ÄÏóêÎßå Îç∞Ïù¥ÌÑ∞Í∞Ä Ï†ÄÏû•Îê©ÎãàÎã§.
                        </p>
                    </div>
                </div>
            `;
            
            // Add event listeners
            setTimeout(() => {
                const googleBtn = overlay.querySelector('#google-signin-btn');
                const localBtn = overlay.querySelector('#local-storage-btn');
                const errorDiv = overlay.querySelector('#auth-error');
                
                googleBtn.addEventListener('click', async () => {
                    googleBtn.disabled = true;
                    googleBtn.querySelector('span').textContent = 'Î°úÍ∑∏Ïù∏ Ï§ë...';
                    try {
                        await userManager.signInWithGoogle();
                    } catch (err) {
                        errorDiv.textContent = 'Î°úÍ∑∏Ïù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.';
                        errorDiv.classList.remove('hidden');
                        googleBtn.disabled = false;
                        googleBtn.querySelector('span').textContent = 'GoogleÎ°ú Í≥ÑÏÜçÌïòÍ∏∞';
                    }
                });
                
                localBtn.addEventListener('click', () => {
                    localStorage.setItem('skipAuth', 'true');
                    overlay.remove();
                    initMindMap();
                });
            }, 100);
            
            return overlay;
        }
        
        // User Profile Component
        function createUserProfile() {
            const container = document.createElement('div');
            container.className = 'user-profile-button mb-4';
            
            const user = userManager.currentUser;
            const profile = userManager.userProfile;
            
            if (!user) return null;
            
            container.innerHTML = `
                <button id="user-profile-btn" class="flex items-center gap-2 px-3 py-2 rounded-lg hover:bg-gray-100 transition-all duration-200 w-full">
                    ${profile?.avatar_url ? 
                        `<img src="${profile.avatar_url}" class="w-8 h-8 rounded-full" />` :
                        `<div class="w-8 h-8 rounded-full bg-gradient-to-br from-purple-500 to-pink-600 flex items-center justify-center text-white text-sm font-bold">
                            ${profile?.full_name?.charAt(0) || user.email?.charAt(0).toUpperCase()}
                        </div>`
                    }
                    <span class="text-sm font-medium text-gray-700">
                        ${profile?.full_name || user.email?.split('@')[0]}
                    </span>
                    <svg class="w-4 h-4 text-gray-500 ml-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                    </svg>
                </button>
                <div id="user-dropdown" class="user-dropdown">
                    <div class="p-3 border-b border-gray-100">
                        <div class="text-sm font-medium text-gray-900">${profile?.full_name || ''}</div>
                        <div class="text-xs text-gray-500">${user.email}</div>
                        <div class="text-xs text-gray-400 mt-1">
                            ${profile?.subscription_tier === 'free' ? 'Î¨¥Î£å ÌîåÎûú' : 
                             profile?.subscription_tier === 'basic' ? 'Î≤†Ïù¥ÏßÅ ÌîåÎûú' :
                             profile?.subscription_tier === 'premium' ? 'ÌîÑÎ¶¨ÎØ∏ÏóÑ ÌîåÎûú' : 'ÏóîÌÑ∞ÌîÑÎùºÏù¥Ï¶à'}
                        </div>
                    </div>
                    <div class="py-1">
                        ${userManager.isAdmin() ? 
                            '<a href="admin.html" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üõ†Ô∏è Í¥ÄÎ¶¨Ïûê Ìå®ÎÑê</a>' : ''}
                        <a href="dashboard.html" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üìä ÎåÄÏãúÎ≥¥Îìú</a>
                        <button id="sync-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üîÑ ÎèôÍ∏∞Ìôî</button>
                        <button id="signout-btn" class="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">üö™ Î°úÍ∑∏ÏïÑÏõÉ</button>
                    </div>
                </div>
            `;
            
            // Add event listeners
            setTimeout(() => {
                const profileBtn = container.querySelector('#user-profile-btn');
                const dropdown = container.querySelector('#user-dropdown');
                const syncBtn = container.querySelector('#sync-btn');
                const signoutBtn = container.querySelector('#signout-btn');
                
                profileBtn?.addEventListener('click', () => {
                    dropdown.classList.toggle('show');
                });
                
                syncBtn?.addEventListener('click', async () => {
                    await syncManager.syncAll();
                });
                
                signoutBtn?.addEventListener('click', async () => {
                    await userManager.signOut();
                    window.location.reload();
                });
                
                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!container.contains(e.target)) {
                        dropdown.classList.remove('show');
                    }
                });
            }, 100);
            
            return container;
        }
        
        // Initialize MindMap with authentication
        let mindMap;
        
        async function initMindMap() {
            // Load data from cloud if authenticated
            if (userManager.isLoggedIn()) {
                const cloudMindmaps = await userManager.loadMindmaps();
                if (cloudMindmaps) {
                    localStorage.setItem('mindMapBoards', JSON.stringify(cloudMindmaps));
                }
                
                // Initialize sync manager
                await syncManager.initializeSync();
                
                // Set up real-time sync for mindmap updates
                window.updateMindmapUI = () => {
                    const storedBoards = localStorage.getItem('mindMapBoards');
                    if (storedBoards && mindMap) {
                        const boards = JSON.parse(storedBoards);
                        mindMap.boards = new Map(boards.map(b => [b.id, b]));
                        if (mindMap.currentBoardId && boards.find(b => b.id === mindMap.currentBoardId)) {
                            mindMap.loadBoard(mindMap.currentBoardId);
                        }
                    }
                };
            }
            
            // Initialize MindMap
            mindMap = new MindMap();
            
            // Add sync indicator
            const syncIndicator = document.createElement('div');
            syncIndicator.id = 'sync-indicator';
            syncIndicator.className = 'sync-indicator offline';
            syncIndicator.innerHTML = '<span>üîÑ</span><span>Ïò§ÌîÑÎùºÏù∏</span>';
            document.body.appendChild(syncIndicator);
            
            // Add user profile to sidebar if logged in
            if (userManager.isLoggedIn()) {
                const sidebar = document.getElementById('sidebar');
                const profileComponent = createUserProfile();
                if (profileComponent && sidebar) {
                    const titleElement = sidebar.querySelector('.p-6');
                    if (titleElement) {
                        titleElement.insertAdjacentElement('afterend', profileComponent);
                    }
                }
            }
            
            // Update save function to sync with cloud
            const originalSaveBoards = mindMap.saveBoards.bind(mindMap);
            mindMap.saveBoards = async function() {
                originalSaveBoards();
                
                // Sync with cloud if authenticated
                if (userManager.isLoggedIn()) {
                    const boardsArray = Array.from(this.boards.values());
                    await userManager.saveMindmaps(boardsArray);
                }
            };
        }
        
        // Check authentication on load
        async function checkAuth() {
            const { data: { session } } = await supabase.auth.getSession();
            
            if (session || localStorage.getItem('skipAuth')) {
                // User is authenticated or chose to skip
                initMindMap();
            } else {
                // Show auth overlay
                document.body.appendChild(AuthOverlay());
            }
        }
        
        // Start the app
        checkAuth();
    </script>
</body>
</html>